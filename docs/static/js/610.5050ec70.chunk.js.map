{"version":3,"file":"static/js/610.5050ec70.chunk.js","mappings":"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","sources":["core/solutionState.ts","core/solutionBase.ts","core/solutionInfo.ts","solutions/day01.ts","core/helpers.ts","solutions/day02.ts","solutions/day03.ts","solutions/day04.ts","solutions/day05.ts","solutions/day06.ts","solutions/day07.ts","solutions/day08.ts","solutions/day09.ts","solutions/day10.ts","web/services/solution.worker.ts","core/solutionManager.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["export type SolutionState = SolutionNotStarted | SolutionProgress | SolutionResult | SolutionError | SolutionCanceled;\r\n\r\nexport class SolutionNotStarted {\r\n    kind = 'not_started' as const;\r\n\r\n    constructor(\r\n        public part: number\r\n    ) { }\r\n}\r\n\r\nexport class SolutionProgress {\r\n    kind = 'progress' as const;\r\n\r\n    constructor(\r\n        public part: number,\r\n        public progress: number,\r\n        public timeMs: number = 0\r\n    ) { }\r\n}\r\n\r\nexport class SolutionResult {\r\n    kind = 'result' as const;\r\n\r\n    constructor(\r\n        public part: number,\r\n        public result: string | null,\r\n        public timeMs: number,\r\n        public visualizationData?: unknown\r\n    ) { }\r\n}\r\n\r\nexport class SolutionError {\r\n    kind = 'error' as const;\r\n\r\n    constructor(\r\n        public part: number,\r\n        public message: string,\r\n        public timeMs: number = 0\r\n    ) { }\r\n}\r\n\r\nexport class SolutionCanceled {\r\n    kind = 'canceled' as const;\r\n\r\n    constructor(\r\n        public part: number,\r\n        public timeMs: number = 0\r\n    ) { }\r\n}","import { lastValueFrom, Observable, Subscriber } from 'rxjs';\r\nimport { Stopwatch } from 'ts-stopwatch';\r\nimport { SolutionError, SolutionProgress, SolutionResult, SolutionState } from './solutionState';\r\n\r\ninterface CurrentSolution {\r\n    subscriber: Subscriber<SolutionState>;\r\n    activePart: number;\r\n    progressStopwatch: Stopwatch;\r\n    stopwatch: Stopwatch;\r\n}\r\n\r\nexport default abstract class SolutionBase {\r\n    /** Minimum elapsed milliseconds between progress updates. */\r\n    minTimeBetweenUpdatesMs = 20;\r\n\r\n    protected visualizationData?: unknown;\r\n    protected get input(): string { return this._input ?? ''; }\r\n    protected get inputLines(): string[] {\r\n        if (this._inputLines === undefined) {\r\n            this._inputLines = this.parseInputLines(this.input);\r\n        }\r\n        return this._inputLines;\r\n    }\r\n\r\n    private _input?: string;\r\n    private _inputLines?: string[];\r\n    private currentSolution?: CurrentSolution;\r\n\r\n    /**\r\n     * Initializes the solution with the given input.\r\n     * @param input \r\n     */\r\n    init(input: string): this {\r\n        this._input = input;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Solves a part asynchronously.\r\n     * @returns The result as string, or null if there was an error.\r\n     */\r\n    async solveAsync(part: 1 | 2): Promise<string | null> {\r\n        const state = await lastValueFrom(this.solveWithProgress(part));\r\n        switch (state.kind) {\r\n            case 'result': return state.result;\r\n            default: return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Solves the given part with progress updates.\r\n     * @returns Observable usable to track the solution progress.\r\n     */\r\n    solveWithProgress(part: 1 | 2): Observable<SolutionState> {\r\n        return new Observable<SolutionState>(subscriber => {\r\n            if (!this._input) {\r\n                subscriber.error(new SolutionError(part, 'No input provided!'));\r\n                return;\r\n            }\r\n            if (this.currentSolution) {\r\n                subscriber.error(new SolutionError(part, 'Another solution is already in progress!'));\r\n                return;\r\n            }\r\n\r\n            const partFunction = part === 1 ? this.part1 : this.part2;\r\n            this.currentSolution = {\r\n                activePart: part,\r\n                subscriber: subscriber,\r\n                stopwatch: new Stopwatch(),\r\n                progressStopwatch: new Stopwatch()\r\n            };\r\n            this.visualizationData = null;\r\n            this.currentSolution.stopwatch.start();\r\n            this.currentSolution.progressStopwatch.start();\r\n\r\n            try {\r\n                const result = partFunction.apply(this) + '';\r\n                const timeMs = this.currentSolution.stopwatch.stop();\r\n                const resultPack = new SolutionResult(part, result, timeMs, this.visualizationData);\r\n                subscriber.next(resultPack);\r\n            } catch (exception) {\r\n                const timeMs = this.currentSolution.stopwatch.stop() ?? 0;\r\n                subscriber.next(new SolutionError(part, exception + '', timeMs));\r\n            } finally {\r\n                subscriber.complete();\r\n                this.visualizationData = null;\r\n                this.currentSolution = undefined;\r\n            }\r\n        });\r\n    }\r\n\r\n    /** Solution for part 1. */\r\n    protected abstract part1(): string | number;\r\n\r\n    /** Solution for part 2. */\r\n    protected abstract part2(): string | number;\r\n\r\n    /**\r\n     * Updates the progress of the solution.\r\n     * @param progress Status of the progress between 0..1.\r\n     */\r\n    protected updateProgress(progress: number): void {\r\n        const current = this.currentSolution;\r\n        if (current && current.progressStopwatch.getTime() > this.minTimeBetweenUpdatesMs) {\r\n            current.subscriber.next(\r\n                new SolutionProgress(current.activePart, progress, current.stopwatch.getTime())\r\n            );\r\n            current.progressStopwatch.start(true);\r\n        }\r\n    }\r\n\r\n    /** Throws an error. Placeholder for when there is no solution yet. */\r\n    protected noSolution(msg?: string): never {\r\n        msg = msg ?? 'No solution available.';\r\n        throw new Error(msg);\r\n    }\r\n\r\n    /** Parses the input lines into a string array omitting the tailing empty lines. */\r\n    private parseInputLines(input: string): string[] {\r\n        const newLineRegex = /\\r\\n?|\\n/g;\r\n        const inputLines = input.split(newLineRegex);\r\n\r\n        let emptyCount: number;\r\n        const whiteSpaceLineRegex = /^\\s*$/gm;\r\n        for (emptyCount = 0; emptyCount < inputLines.length; emptyCount++) {\r\n            const line = inputLines[inputLines.length - emptyCount - 1];\r\n            if (!whiteSpaceLineRegex.test(line)) {\r\n                break;\r\n            }\r\n        }\r\n        inputLines.splice(inputLines.length - emptyCount, emptyCount);\r\n\r\n        return inputLines;\r\n    }\r\n}","import SolutionBase from './solutionBase';\r\n\r\nconst solutionInfoList: SolutionInfo[] = [];\r\n\r\nexport type Constructor<T> = {\r\n    new(...args: unknown[]): T;\r\n    readonly prototype: T;\r\n};\r\n\r\nexport type SolutionInfoParams = {\r\n    day: number;\r\n    title: string;\r\n};\r\n\r\nexport type SolutionInfo = SolutionInfoParams & {\r\n    ctor: Constructor<SolutionBase>;\r\n    create: () => SolutionBase;\r\n};\r\n\r\nexport function solutionInfo<TCtor extends Constructor<SolutionBase>>(day: number, title: string): (ctor: TCtor) => void;\r\nexport function solutionInfo<TCtor extends Constructor<SolutionBase>>(info: SolutionInfoParams): (ctor: TCtor) => void;\r\nexport function solutionInfo<TCtor extends Constructor<SolutionBase>>(...params: [number, string] | [SolutionInfoParams]): (ctor: TCtor) => void {\r\n    const info = typeof params[0] === 'number' ? { day: params[0], title: params[1] as string } : params[0];\r\n    return (ctor: TCtor): void => {\r\n        solutionInfoList.push({\r\n            ...info,\r\n            ctor: ctor,\r\n            create: () => new ctor()\r\n        });\r\n    };\r\n}\r\n\r\nexport { solutionInfoList };\r\n\r\n","import SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\n@solutionInfo({\r\n    day: 1,\r\n    title: 'Sonar Sweep'\r\n})\r\nexport class Day01 extends SolutionBase {\r\n\r\n    protected part1(): number {\r\n        const values = this.inputLines.map(x => parseInt(x));\r\n        const increaseCount = values.slice(1).reduce((a, x, i) => a + (values[i] < x ? 1 : 0), 0);\r\n\r\n        return increaseCount;\r\n    }\r\n\r\n    protected part2(): number {\r\n        const values = this.inputLines.map(x => parseInt(x));\r\n        const sumsOf3 = values.slice(2).map((x, i) => values[i] + values[i + 1] + x);\r\n        const increaseCount = sumsOf3.slice(1).reduce((a, x, i) => a + (sumsOf3[i] < x ? 1 : 0), 0);\r\n\r\n        return increaseCount;\r\n    }\r\n}\r\n","/**\r\n * Executes the regular expression over and over on the given text until all matches are found.\r\n * @param regex The regular expression.\r\n * @param text The text.\r\n */\r\nfunction regexMatches(regex: RegExp, text: string): RegExpExecArray[] {\r\n    const results: RegExpExecArray[] = [];\r\n    let record: RegExpExecArray | null;\r\n\r\n    while ((record = regex.exec(text))) {\r\n        results.push(record);\r\n    }\r\n\r\n    return results;\r\n}\r\n\r\nfunction* regexMatchesLazy(regex: RegExp, text: string): Generator<RegExpExecArray, void, unknown> {\r\n    let record: RegExpExecArray | null;\r\n    while ((record = regex.exec(text))) {\r\n        yield record;\r\n    }\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nfunction assertNever(value: never, shouldThrow = true): void | never {\r\n    if (shouldThrow) {\r\n        throw new Error('Coding error! This path should never be reached!');\r\n    }\r\n}\r\n\r\nfunction get2DigitDay(day: number): string {\r\n    return day.toString().padStart(2, '0');\r\n}\r\n\r\n/** Performs a logical XOR operation on the two parameters. */\r\nfunction xor(a: boolean, b: boolean): boolean {\r\n    return a !== b; // (a || b) && !(a && b);\r\n}\r\n\r\nfunction intersectSets<T>(a: Set<T>, b: Set<T>): Set<T> {\r\n    return new Set([...a].filter(x => b.has(x)));\r\n}\r\n\r\nexport {\r\n    assertNever,\r\n    regexMatches,\r\n    regexMatchesLazy,\r\n    get2DigitDay,\r\n    xor,\r\n    intersectSets\r\n};\r\n\r\n","import { regexMatches } from '../core/helpers';\r\nimport SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\n@solutionInfo({\r\n    day: 2,\r\n    title: 'Dive!'\r\n})\r\nexport class Day02 extends SolutionBase {\r\n\r\n    protected part1(): number {\r\n        const sub = { hor: 0, dep: 0 };\r\n        this.parseInput().forEach(command => {\r\n            sub.hor += command.hor;\r\n            sub.dep += command.dep;\r\n        });\r\n\r\n        return sub.hor * sub.dep;\r\n    }\r\n\r\n    protected part2(): number {\r\n        const sub = { hor: 0, dep: 0, aim: 0 };\r\n        this.parseInput().forEach(command => {\r\n            sub.aim += command.dep;\r\n            sub.hor += command.hor;\r\n            sub.dep += sub.aim * command.hor;\r\n        });\r\n\r\n        return sub.hor * sub.dep;\r\n    }\r\n\r\n    private parseInput() {\r\n        return regexMatches(/([a-z]+) (\\d+)/g, this.input).map(match => {\r\n            const [, commandStr, valueStr] = match;\r\n            const value = parseInt(valueStr);\r\n            const command = { hor: 0, dep: 0 };\r\n            switch (commandStr) {\r\n                case 'forward': command.hor += value; break;\r\n                case 'down': command.dep += value; break;\r\n                case 'up': command.dep -= value; break;\r\n                default: throw new Error('Invalid input!');\r\n            }\r\n            return command;\r\n        });\r\n    }\r\n}\r\n","import { xor } from '../core/helpers';\r\nimport SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\ntype KeepMode = 'most_common' | 'least_common';\r\n\r\n@solutionInfo({\r\n    day: 3,\r\n    title: 'Binary Diagnostic'\r\n})\r\nexport class Day03 extends SolutionBase {\r\n\r\n    protected part1(): number {\r\n        const binaryNumbers = this.inputLines;\r\n        const halfCount = binaryNumbers.length / 2;\r\n        const bitCounts = binaryNumbers[0].split('').map((_, pos) =>\r\n            binaryNumbers.reduce((a, bNumber) => a + parseInt(bNumber[pos]), 0)\r\n        );\r\n\r\n        const gamma = parseInt(bitCounts.map(x => x >= halfCount ? '1' : '0').join(''), 2);\r\n        const epsilon = parseInt(bitCounts.map(x => x < halfCount ? '1' : '0').join(''), 2);\r\n\r\n        return gamma * epsilon;\r\n    }\r\n\r\n    protected part2(): number {\r\n        const binaryNumbers = this.inputLines;\r\n        const oxygenGeneratorRating = this.getRating(binaryNumbers, 'most_common');\r\n        const co2ScrubberRating = this.getRating(binaryNumbers, 'least_common');\r\n\r\n        return oxygenGeneratorRating * co2ScrubberRating;\r\n    }\r\n\r\n    private getRating(bNumbers: string[], keep: KeepMode): number {\r\n        for (let pos = 0; pos < bNumbers[0].length; pos++) {\r\n            bNumbers = this.filter(bNumbers, pos, keep);\r\n            if (bNumbers.length === 1) { break; }\r\n        }\r\n\r\n        return parseInt(bNumbers[0], 2);\r\n    }\r\n\r\n    private filter(bNumbers: string[], position: number, keep: KeepMode): string[] {\r\n        const bitCount = bNumbers.reduce((a, x) => a + parseInt(x[position]), 0);\r\n        const keepBit = xor(bitCount >= bNumbers.length / 2, keep === 'least_common') ? '1' : '0';\r\n\r\n        return bNumbers.filter(x => x[position] === keepBit);\r\n    }\r\n}\r\n","import { regexMatches } from '../core/helpers';\r\nimport SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\nconst boardSize = 5;\r\n\r\n@solutionInfo({\r\n    day: 4,\r\n    title: 'Giant Squid'\r\n})\r\nexport class Day04 extends SolutionBase {\r\n\r\n    protected part1(): number {\r\n        return this.playBingo('play to win');\r\n    }\r\n\r\n    protected part2(): number {\r\n        return this.playBingo('let the giant squid win');\r\n    }\r\n\r\n    private playBingo(strategy: 'play to win' | 'let the giant squid win'): number {\r\n        const { numbers, boards, lookup } = this.parseInput();\r\n        const marks: boolean[][][] = boards.map(() => Array(boardSize).fill(0).map(() => Array(boardSize).fill(false)));\r\n        const wins: Set<number> = new Set();\r\n        const targetWinCount = strategy === 'play to win' ? 1 : boards.length;\r\n\r\n        for (const calledNumber of numbers) {\r\n            const hits = lookup.get(calledNumber);\r\n            if (!hits) { continue; }\r\n\r\n            for (const { ti, tj, tk } of hits) {\r\n                marks[ti][tj][tk] = true;\r\n\r\n                if (!wins.has(ti) && this.isBingo(marks[ti], tj, tk)) {\r\n                    wins.add(ti);\r\n                    if (wins.size === targetWinCount) {\r\n                        const sum = boards[ti].reduce((boardSum, rowNumbers, row) =>\r\n                            boardSum + rowNumbers.reduce((rowSum, aNumber, col) =>\r\n                                rowSum + (marks[ti][row][col] ? 0 : aNumber), 0), 0);\r\n\r\n                        return sum * calledNumber;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this.noSolution();\r\n    }\r\n\r\n    private isBingo(board: boolean[][], hitRow: number, hitCol: number): boolean {\r\n        let row = true;\r\n        let col = true;\r\n        for (let i = 0; i < boardSize; i++) {\r\n            row &&= board[i][hitCol];\r\n            col &&= board[hitRow][i];\r\n            if (!row && !col) { return false; }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private parseInput() {\r\n        const numbers = this.parseNumbersInLine(this.inputLines[0]);\r\n        const boards: number[][][] = [];\r\n        const lookup = new Map<number, { ti: number, tj: number, tk: number; }[]>();\r\n\r\n        let lineIndex = 1;\r\n        while (lineIndex < this.inputLines.length) {\r\n            const board: number[][] = [];\r\n            const ti = boards.push(board) - 1;\r\n\r\n            let line: string;\r\n            while ((line = this.inputLines[++lineIndex])) {\r\n                const rowNumbers = this.parseNumbersInLine(line);\r\n                const tj = board.push(rowNumbers) - 1;\r\n                rowNumbers.map((n, tk) => {\r\n                    let lookupEntry = lookup.get(n);\r\n                    if (!lookupEntry) { lookup.set(n, (lookupEntry = [])); }\r\n                    lookupEntry.push({ ti, tj, tk });\r\n                });\r\n            }\r\n        }\r\n\r\n        return { numbers, boards, lookup };\r\n    }\r\n\r\n    private parseNumbersInLine(line: string): number[] {\r\n        return regexMatches(/\\d+/g, line).map(match => parseInt(match[0]));\r\n    }\r\n}\r\n","import { regexMatches } from '../core/helpers';\r\nimport SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\ninterface Pipe { x1: number; y1: number; x2: number; y2: number; }\r\n\r\n@solutionInfo({\r\n    day: 5,\r\n    title: 'Hydrothermal Venture'\r\n})\r\nexport class Day05 extends SolutionBase {\r\n\r\n    protected part1(): number {\r\n        const pipes = this.parsePipes();\r\n        const map = this.createMap(pipes, 'skip diagonals');\r\n        const overlapCount = this.countOverlaps(map);\r\n\r\n        return overlapCount;\r\n    }\r\n\r\n    protected part2(): number {\r\n        const pipes = this.parsePipes();\r\n        const map = this.createMap(pipes, 'include diagonals');\r\n        const overlapCount = this.countOverlaps(map);\r\n\r\n        return overlapCount;\r\n    }\r\n\r\n    private countOverlaps(map: number[][]): number {\r\n        return map.reduce((a, row) => a + row.reduce((a, x) => a + (x > 1 ? 1 : 0), 0), 0);\r\n    }\r\n\r\n    private createMap(pipes: Pipe[], mode: 'skip diagonals' | 'include diagonals'): number[][] {\r\n        const map: number[][] = [];\r\n        const skipDiagonals = mode === 'skip diagonals';\r\n        for (const { x1, y1, x2, y2 } of pipes) {\r\n            if (skipDiagonals && x1 !== x2 && y1 !== y2) {\r\n                continue;\r\n            }\r\n            this.drawLine(map, x1, y1, x2, y2);\r\n        }\r\n\r\n        return map;\r\n    }\r\n\r\n    private drawLine(map: number[][], x1: number, y1: number, x2: number, y2: number) {\r\n        const dx = Math.sign(x2 - x1);\r\n        const dy = Math.sign(y2 - y1);\r\n\r\n        let [x, y] = [null, null] as (number | null)[];\r\n        while (x !== x2 || y !== y2) {\r\n            x = (x ?? x1 - dx) + dx;\r\n            y = (y ?? y1 - dy) + dy;\r\n\r\n            if (map[y] === undefined) { map[y] = []; }\r\n            if (map[y][x] === undefined) { map[y][x] = 0; }\r\n            map[y][x]++;\r\n        }\r\n    }\r\n\r\n    private parsePipes(): Pipe[] {\r\n        return regexMatches(/(\\d+),(\\d+) -> (\\d+),(\\d+)/g, this.input).map(match => {\r\n            const [x1, y1, x2, y2] = match.slice(1).map(x => parseInt(x));\r\n            return { x1, y1, x2, y2 };\r\n        });\r\n    }\r\n}\r\n","import { regexMatches } from '../core/helpers';\r\nimport SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\nconst restartAge = 6;\r\nconst newBornAge = 8;\r\n\r\n@solutionInfo({\r\n    day: 6,\r\n    title: 'Lanternfish'\r\n})\r\nexport class Day06 extends SolutionBase {\r\n\r\n    protected part1(): number {\r\n        return this.simulateLanternfish(80);\r\n    }\r\n\r\n    protected part2(): number {\r\n        return this.simulateLanternfish(256);\r\n    }\r\n\r\n    private simulateLanternfish(dayCount: number): number {\r\n        const ages: number[] = Array(newBornAge + 1).fill(0);\r\n        const fishes = regexMatches(/\\d/g, this.input).map(x => parseInt(x[0]));\r\n        fishes.forEach(x => ages[x]++);\r\n\r\n        for (let day = 0; day < dayCount; day++) {\r\n            const count = ages.shift() as number;\r\n            ages[newBornAge] = count;\r\n            ages[restartAge] += count;\r\n        }\r\n\r\n        const population = ages.reduce((a, x) => a + x, 0);\r\n        return population;\r\n    }\r\n}\r\n","import { regexMatches } from '../core/helpers';\r\nimport SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\n@solutionInfo({\r\n    day: 7,\r\n    title: 'The Treachery of Whales'\r\n})\r\nexport class Day07 extends SolutionBase {\r\n\r\n    protected part1(): number {\r\n        const { crabs, minPos, maxPos } = this.parseInput();\r\n\r\n        let minMoves = Number.MAX_VALUE;\r\n        for (let target = minPos; target <= maxPos; target++) {\r\n            const moves = crabs.reduce((a, x) => a + Math.abs(x - target), 0);\r\n            minMoves = Math.min(minMoves, moves);\r\n        }\r\n\r\n        return minMoves;\r\n    }\r\n\r\n    protected part2(): number {\r\n        const { crabs, minPos, maxPos } = this.parseInput();\r\n\r\n        let minMoves = Number.MAX_VALUE;\r\n        for (let target = minPos; target <= maxPos; target++) {\r\n            const moves = crabs.reduce((a, x) => {\r\n                const delta = Math.abs(x - target);\r\n                const fuel = delta * (delta + 1) / 2;\r\n                return a + fuel;\r\n            }, 0);\r\n            minMoves = Math.min(minMoves, moves);\r\n        }\r\n\r\n        return minMoves;\r\n    }\r\n\r\n    private parseInput() {\r\n        let minPos = Number.MAX_VALUE;\r\n        let maxPos = Number.MIN_VALUE;\r\n\r\n        const crabs = regexMatches(/\\d+/g, this.input).map(x => {\r\n            const pos = parseInt(x[0]);\r\n            minPos = Math.min(minPos, pos);\r\n            maxPos = Math.max(maxPos, pos);\r\n            return pos;\r\n        });\r\n\r\n        return { crabs, minPos, maxPos };\r\n    }\r\n}\r\n","import { intersectSets, regexMatches } from '../core/helpers';\r\nimport SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\ntype Display = { patterns: string[]; digits: string[]; };\r\ntype VagueSegmentMap = { from: string; to: string[]; }[];\r\ntype SegmentMap = { [from: string]: string; };\r\ntype ReadOnlySet<T> = { has: (item: T) => boolean; };\r\n\r\nconst digitSegments: readonly string[] = ['abcefg', 'cf', 'acdeg', 'acdfg', 'bcdf', 'abdfg', 'abdefg', 'acf', 'abcdefg', 'abcdfg'];\r\nconst digitSegmentSet: ReadOnlySet<string> = new Set(digitSegments);\r\n\r\n@solutionInfo({\r\n    day: 8,\r\n    title: 'Seven Segment Search'\r\n})\r\nexport class Day08 extends SolutionBase {\r\n\r\n    protected part1(): number {\r\n        const uniqueLengths = new Set([2, 3, 4, 7]);\r\n        const displays = this.parseInput();\r\n        const uniqueCount = displays.reduce((a, r) => a +\r\n            r.digits.reduce((a, d) => a + (uniqueLengths.has(d.length) ? 1 : 0), 0), 0);\r\n\r\n        return uniqueCount;\r\n    }\r\n\r\n    protected part2(): number {\r\n        const displays = this.parseInput();\r\n        const sum = displays.reduce((a, display, i) => {\r\n            this.updateProgress(i / displays.length);\r\n            return a + this.decodeDisplayValue(display);\r\n        }, 0);\r\n\r\n        return sum;\r\n    }\r\n\r\n    /** Decodes the value shown on the display. */\r\n    private decodeDisplayValue({ patterns, digits }: Display): number {\r\n        const vagueSegmentMap = this.generateVagueSegmentMap(patterns);\r\n        const segmentMap = this.resolveSegmentMap(vagueSegmentMap, patterns);\r\n        if (!segmentMap) { this.noSolution(); }\r\n\r\n        const displayValue = parseInt(digits.map(x => this.decodeDigit(x, segmentMap)).join(''));\r\n        return displayValue;\r\n    }\r\n\r\n    /** Finds the correct mapping from the initial segment map using backtrack. */\r\n    private resolveSegmentMap(vagueMap: VagueSegmentMap, patterns: string[], index = 0): SegmentMap | null {\r\n        if (index === vagueMap.length) {\r\n            const completedMap = Object.fromEntries(vagueMap.map(x => [x.from, x.to[0]]));\r\n            return this.isSegmentMapValid(completedMap, patterns) ? completedMap : null;\r\n        }\r\n\r\n        const candidateChars = vagueMap[index].to;\r\n        for (const selectedChar of candidateChars) {\r\n            const nextMap = [\r\n                ...vagueMap.slice(0, index),\r\n                { from: vagueMap[index].from, to: [selectedChar] },\r\n                ...vagueMap.slice(index + 1).map(x => ({\r\n                    from: x.from,\r\n                    to: x.to.filter(c => c !== selectedChar)\r\n                }))\r\n            ];\r\n\r\n            const result = this.resolveSegmentMap(nextMap, patterns, index + 1);\r\n            if (result) { return result; }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** Checks if each pattern can be mapped to a digit using the segment map. */\r\n    private isSegmentMapValid(map: SegmentMap, patterns: string[]): boolean {\r\n        return patterns.every(p => digitSegmentSet.has(this.decodeSegments(p, map)));\r\n    }\r\n\r\n    /** Decodes a segment string and finds to the corresponding digit. */\r\n    private decodeDigit(segments: string, map: SegmentMap): number {\r\n        return digitSegments.indexOf(this.decodeSegments(segments, map));\r\n    }\r\n\r\n    /** Decodes an encoded segment string. */\r\n    private decodeSegments(segments: string, map: SegmentMap): string {\r\n        return segments.split('').map(x => map[x]).sort().join('');\r\n    }\r\n\r\n    /** Generates a vague segment map where each character can have multiple possible mappings. */\r\n    private generateVagueSegmentMap(patterns: string[]): VagueSegmentMap {\r\n        const digitsSegmentsByLength = new Map<number, string[][]>(Array(8).fill(0).map((_, i) => [i, []]));\r\n        digitSegments.forEach(x => digitsSegmentsByLength.get(x.length)!.push(x.split('')));\r\n\r\n        const resultMap = new Map<string, Set<string>>();\r\n        for (const pattern of patterns) {\r\n            // Generate possible segment mappings based on pattern\r\n            const patternMap = new Map<string, Set<string>>();\r\n            const validDigits = digitsSegmentsByLength.get(pattern.length)!;\r\n            pattern.split('').forEach(patternChar =>\r\n                validDigits.forEach(vd => vd.forEach(digitChar => {\r\n                    if (!patternMap.has(patternChar)) { patternMap.set(patternChar, new Set()); }\r\n                    patternMap.get(patternChar)!.add(digitChar);\r\n                }))\r\n            );\r\n\r\n            // Intersect with previous mappings\r\n            for (const [key, newChars] of patternMap.entries()) {\r\n                if (!resultMap.has(key)) {\r\n                    resultMap.set(key, newChars);\r\n                } else {\r\n                    const currentChars = resultMap.get(key)!;\r\n                    resultMap.set(key, intersectSets(currentChars, newChars));\r\n                }\r\n            }\r\n        }\r\n\r\n        // Generate sorted vague segment map\r\n        return [...resultMap.entries()]\r\n            .map(x => ({ from: x[0], to: [...x[1]] }))\r\n            .sort((a, b) => a.to.length - b.to.length);\r\n    }\r\n\r\n    private parseInput(): Display[] {\r\n        const displays = regexMatches(/(.+) \\| (.+)/g, this.input).map(displayMatch => {\r\n            const [, patternsStr, digitsStr] = displayMatch;\r\n            const patterns = regexMatches(/[a-g]+/g, patternsStr).map(x => x[0]);\r\n            const digits = regexMatches(/[a-g]+/g, digitsStr).map(x => x[0]);\r\n            return { patterns, digits };\r\n        });\r\n\r\n        return displays;\r\n    }\r\n}\r\n","import { regexMatches } from '../core/helpers';\r\nimport SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\ntype Point = { x: number; y: number; };\r\ntype HeightMap = { map: number[][]; width: number; height: number; };\r\nconst neighbors: readonly Point[] = [[-1, 0], [0, -1], [1, 0], [0, 1]].map(p => ({ x: p[0], y: p[1] }));\r\n\r\n@solutionInfo({\r\n    day: 9,\r\n    title: 'Smoke Basin'\r\n})\r\nexport class Day09 extends SolutionBase {\r\n\r\n    protected part1(): number {\r\n        const heightMap = this.parseInput();\r\n        const lowPoints = this.getLowPoints(heightMap);\r\n        const sum = lowPoints.reduce((a, p) => a + 1 + heightMap.map[p.y][p.x], 0);\r\n\r\n        return sum;\r\n    }\r\n\r\n    protected part2(): number {\r\n        const heightMap = this.parseInput();\r\n        const lowPoints = this.getLowPoints(heightMap);\r\n        const basins = lowPoints.map(p => this.flood(heightMap, p));\r\n        const largest3Basins = basins.sort((a, b) => b - a).slice(0, 3);\r\n        const product = largest3Basins.reduce((a, x) => a * x, 1);\r\n\r\n        return product;\r\n    }\r\n\r\n    private getLowPoints({ map, width, height }: HeightMap): Point[] {\r\n        const lowPoints: Point[] = [];\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const current = map[y][x];\r\n                const isLowPoint = neighbors\r\n                    .map(np => map[y + np.y] && map[y + np.y][x + np.x])\r\n                    .every(n => n === undefined || current < n);\r\n                if (isLowPoint) {\r\n                    lowPoints.push({ x, y });\r\n                }\r\n            }\r\n        }\r\n\r\n        return lowPoints;\r\n    }\r\n\r\n    /**\r\n     * Floods an area starting from the given point to calculate it's size.\r\n     * Areas are delimited by '9'-s.\r\n     */\r\n    private flood({ map, width, height }: HeightMap, start: Point): number {\r\n        const toIndex = (p: Point) => p.y * width + p.x;\r\n        const visitedIndexes = new Set<number>();\r\n        const queue: Point[] = [start];\r\n\r\n        while (queue.length > 0) {\r\n            const point = queue.shift()!;\r\n            const pointIndex = toIndex(point);\r\n\r\n            if (visitedIndexes.has(pointIndex)) { continue; }\r\n            visitedIndexes.add(pointIndex);\r\n\r\n            neighbors.forEach(np => {\r\n                const nextX = point.x + np.x;\r\n                const nextY = point.y + np.y;\r\n                if (nextX >= 0 && nextX < width &&\r\n                    nextY >= 0 && nextY < height &&\r\n                    map[nextY][nextX] < 9\r\n                ) {\r\n                    queue.push({ x: nextX, y: nextY });\r\n                }\r\n            });\r\n        }\r\n\r\n        return visitedIndexes.size;\r\n    }\r\n\r\n    private parseInput(): HeightMap {\r\n        const map = this.inputLines.map(line =>\r\n            regexMatches(/\\d/g, line).map(x => parseInt(x[0]))\r\n        );\r\n\r\n        return {\r\n            map,\r\n            width: map[0].length,\r\n            height: map.length\r\n        };\r\n    }\r\n}\r\n","import SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\nconst chunkPairs = { '(': ')', '[': ']', '{': '}', '<': '>' } as Record<string, string>;\r\nconst errorPoints = { ')': 3, ']': 57, '}': 1197, '>': 25137 } as Record<string, number>;\r\nconst completePoints = { ')': 1, ']': 2, '}': 3, '>': 4 } as Record<string, number>;\r\n\r\n@solutionInfo({\r\n    day: 10,\r\n    title: 'Syntax Scoring'\r\n})\r\nexport class Day10 extends SolutionBase {\r\n\r\n    protected part1(): number {\r\n        const errorScore = this.inputLines.reduce((a, l) => a + this.score(l, 'check'), 0);\r\n        return errorScore;\r\n    }\r\n\r\n    protected part2(): number {\r\n        const incompleteLines = this.inputLines.filter(l => !this.score(l, 'check'));\r\n        const completeScores = incompleteLines.map(l => this.score(l, 'complete'));\r\n        const middleScore = completeScores.sort((a, b) => a - b)[Math.floor(completeScores.length / 2)];\r\n\r\n        return middleScore;\r\n    }\r\n\r\n    private score(line: string, mode: 'check' | 'complete'): number {\r\n        const stack = [];\r\n        for (const actual of line.split('')) {\r\n            if (chunkPairs[actual]) {\r\n                stack.push(actual);\r\n            } else {\r\n                const chunkStart = stack.pop()!;\r\n                const expected = chunkPairs[chunkStart];\r\n                if (expected !== actual) {\r\n                    return errorPoints[actual];\r\n                }\r\n            }\r\n        }\r\n\r\n        let score = 0;\r\n        if (mode === 'complete') {\r\n            score = stack.reduceRight((a, x) => a * 5 + completePoints[chunkPairs[x]], 0);\r\n        }\r\n\r\n        return score;\r\n    }\r\n}\r\n","/// <reference lib=\"webworker\" />\r\n\r\nimport { lastValueFrom } from 'rxjs';\r\nimport { tap } from 'rxjs/operators';\r\nimport solutionManager from '../../core/solutionManager';\r\nimport { SolutionResult } from '../../core/solutionState';\r\nimport SolveRequest from './solveRequest';\r\n\r\nconst solutionInfos = solutionManager.getSolutionsByDay();\r\n\r\ninterface WorkerRequest {\r\n    data: SolveRequest;\r\n}\r\n\r\naddEventListener('message', async ({ data }: WorkerRequest) => {\r\n    const solutionInfo = solutionInfos.get(data.day);\r\n    if (!solutionInfo) { return; }\r\n\r\n    const solution = solutionInfo.create();\r\n    solution.init(data.input);\r\n\r\n    for (const part of [1, 2] as const) {\r\n        const observable = solution.solveWithProgress(part);\r\n        await lastValueFrom(observable.pipe(\r\n            tap(state => postMessage(state))\r\n        ));\r\n    }\r\n\r\n    // Post an invalid result to mark the end of the work.\r\n    postMessage(new SolutionResult(-1, null, 0));\r\n});\r\n","import '../solutions';\r\nimport { SolutionInfo, solutionInfoList } from './solutionInfo';\r\n\r\nclass SolutionManager {\r\n    /** Get the solutions in a (day, solutionInfo) map. */\r\n    getSolutionsByDay(): Map<number, SolutionInfo> {\r\n        return new Map(solutionInfoList.map(info => [info.day, info]));\r\n    }\r\n\r\n    /** Get the solutions in ascending order by day. */\r\n    getSolutions(): SolutionInfo[] {\r\n        return Array.from(this.getSolutionsByDay().values()).sort((a, b) => a.day - b.day);\r\n    }\r\n}\r\n\r\nconst solutionManager = new SolutionManager();\r\n\r\nexport default solutionManager;\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [85], function() { return __webpack_require__(9610); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"aa5699c0\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/aoc2021/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t610: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkaoc2021\"] = self[\"webpackChunkaoc2021\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(85).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["SolutionProgress","part","progress","timeMs","kind","SolutionResult","result","visualizationData","SolutionError","message","SolutionBase","minTimeBetweenUpdatesMs","_input","_inputLines","currentSolution","this","undefined","parseInputLines","input","lastValueFrom","solveWithProgress","state","Observable","subscriber","error","partFunction","part1","part2","activePart","stopwatch","Stopwatch","progressStopwatch","start","apply","stop","resultPack","next","exception","complete","current","getTime","msg","Error","emptyCount","inputLines","split","whiteSpaceLineRegex","length","line","test","splice","solutionInfoList","solutionInfo","info","day","title","ctor","push","create","values","map","x","parseInt","slice","reduce","a","i","sumsOf3","regexMatches","regex","text","record","results","exec","intersectSets","b","Set","filter","has","sub","hor","dep","parseInput","forEach","command","aim","match","commandStr","valueStr","value","binaryNumbers","halfCount","bitCounts","_","pos","bNumber","join","getRating","bNumbers","keep","position","bitCount","keepBit","playBingo","strategy","numbers","boards","lookup","marks","Array","fill","wins","targetWinCount","calledNumber","hits","get","ti","tj","tk","isBingo","add","size","boardSum","rowNumbers","row","rowSum","aNumber","col","noSolution","board","hitRow","hitCol","parseNumbersInLine","Map","lineIndex","n","lookupEntry","set","pipes","parsePipes","createMap","countOverlaps","mode","skipDiagonals","x1","y1","x2","y2","drawLine","dx","Math","sign","dy","y","simulateLanternfish","dayCount","ages","newBornAge","count","shift","crabs","minPos","maxPos","minMoves","Number","MAX_VALUE","target","moves","abs","min","delta","MIN_VALUE","max","digitSegments","digitSegmentSet","neighbors","uniqueLengths","r","digits","d","displays","display","updateProgress","decodeDisplayValue","patterns","vagueSegmentMap","generateVagueSegmentMap","segmentMap","resolveSegmentMap","decodeDigit","vagueMap","index","completedMap","Object","fromEntries","from","to","isSegmentMapValid","candidateChars","selectedChar","nextMap","c","every","p","decodeSegments","segments","indexOf","sort","digitsSegmentsByLength","resultMap","pattern","patternMap","validDigits","patternChar","vd","digitChar","entries","key","newChars","currentChars","displayMatch","patternsStr","digitsStr","chunkPairs","heightMap","getLowPoints","flood","width","height","lowPoints","np","visitedIndexes","queue","point","pointIndex","nextX","nextY","errorPoints","completePoints","solutionInfos","l","score","completeScores","floor","stack","actual","chunkStart","pop","reduceRight","SolutionManager","getSolutionsByDay","solutionManager","addEventListener","data","solution","init","observable","pipe","tap","postMessage","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","m","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","keys","getter","__esModule","definition","o","defineProperty","enumerable","f","e","chunkId","Promise","all","promises","u","miniCssF","obj","prop","prototype","hasOwnProperty","call","installedChunks","importScripts","chunkLoadingGlobal","self","parentChunkLoadingFunction","bind","moreModules","runtime","then"],"sourceRoot":""}