{"version":3,"file":"static/js/137.1c2481c5.chunk.js","mappings":"gLAUaA,EAGT,WACWC,EACAC,GAER,IADQC,EACT,uDAD0B,GAC1B,oBAHSF,KAAAA,EAGT,KAFSC,SAAAA,EAET,KADSC,OAAAA,EACT,KANFC,KAAO,YASEC,EAGT,WACWJ,EACAK,EACAH,EACAI,IACR,oBAJQN,KAAAA,EAIT,KAHSK,OAAAA,EAGT,KAFSH,OAAAA,EAET,KADSI,kBAAAA,EACT,KAPFH,KAAO,UAUEI,EAGT,WACWP,EACAQ,GAER,IADQN,EACT,uDAD0B,GAC1B,oBAHSF,KAAAA,EAGT,KAFSQ,QAAAA,EAET,KADSN,OAAAA,EACT,KANFC,KAAO,SCrBmBM,EAAAA,WAAAA,SAAAA,KAAAA,EAAAA,EAAAA,GAAAA,KAAAA,GAAAA,KAE1BC,wBAA0B,GAAG,KAEnBJ,uBAAAA,EAAAA,KASFK,YAAAA,EAAAA,KACAC,iBAAAA,EAAAA,KACAC,qBAAAA,EA2GP,OA3GOA,EAAAA,EAAAA,GAAAA,EAAAA,CAAAA,CAAAA,IAAAA,QAAAA,IAVR,WAA+B,IAAD,EAAE,iBAAOC,KAAKH,cAAZ,QAAsB,KAAK,sBAC3D,WAII,YAHyBI,IAArBD,KAAKF,cACLE,KAAKF,YAAcE,KAAKE,gBAAgBF,KAAKG,QAE1CH,KAAKF,cACf,kBAUD,SAAKK,GAED,OADAH,KAAKH,OAASM,EACPH,OAMf,2DACI,WAAiBd,GAAjB,wFACwBkB,EAAAA,EAAAA,GAAcJ,KAAKK,kBAAkBnB,IAD7D,OACUoB,EADV,YAEYA,EAAMjB,KAFlB,OAGa,WAHb,+CAG8BiB,EAAMf,QAHpC,gCAIwB,MAJxB,mGADJ,IAYA,+BACI,SAAkBL,GAAyC,IAAD,OACtD,OAAO,IAAIqB,EAAAA,GAA0B,SAAAC,GACjC,GAAK,EAAKX,OAIV,GAAI,EAAKE,gBACLS,EAAWC,MAAM,IAAIhB,EAAcP,EAAM,iDAD7C,CAKA,IAAMwB,EAAwB,IAATxB,EAAa,EAAKyB,MAAQ,EAAKC,MACpD,EAAKb,gBAAkB,CACnBc,WAAY3B,EACZsB,WAAYA,EACZM,UAAW,IAAIC,EAAAA,EACfC,kBAAmB,IAAID,EAAAA,GAE3B,EAAKvB,kBAAoB,KACzB,EAAKO,gBAAgBe,UAAUG,QAC/B,EAAKlB,gBAAgBiB,kBAAkBC,QAEvC,IACI,IAAM1B,EAASmB,EAAaQ,MAAM,GAAQ,GACpC9B,EAAS,EAAKW,gBAAgBe,UAAUK,OACxCC,EAAa,IAAI9B,EAAeJ,EAAMK,EAAQH,EAAQ,EAAKI,mBACjEgB,EAAWa,KAAKD,GAClB,MAAOE,GAAY,IAAD,EACVlC,EAAM,UAAG,EAAKW,gBAAgBe,UAAUK,cAAlC,QAA4C,EACxDX,EAAWa,KAAK,IAAI5B,EAAcP,EAAMoC,EAAY,GAAIlC,IAP5D,QASIoB,EAAWe,WACX,EAAK/B,kBAAoB,KACzB,EAAKO,qBAAkBE,QA9BvBO,EAAWC,MAAM,IAAIhB,EAAcP,EAAM,4BAmCrD,4BAUA,SAAyBC,GACrB,IAAMqC,EAAUxB,KAAKD,gBACjByB,GAAWA,EAAQR,kBAAkBS,UAAYzB,KAAKJ,0BACtD4B,EAAQhB,WAAWa,KACf,IAAIpC,EAAiBuC,EAAQX,WAAY1B,EAAUqC,EAAQV,UAAUW,YAEzED,EAAQR,kBAAkBC,OAAM,MAIxC,wBACA,SAAqBS,GAAsB,IAAD,EAEtC,MADAA,EAAG,UAAGA,SAAH,QAAU,yBACP,IAAIC,MAAMD,KAGpB,6BACA,SAAwBvB,GACpB,IAGIyB,EAFEC,EAAa1B,EAAM2B,MADJ,aAIfC,EAAsB,UAC5B,IAAKH,EAAa,EAAGA,EAAaC,EAAWG,OAAQJ,IAAc,CAC/D,IAAMK,EAAOJ,EAAWA,EAAWG,OAASJ,EAAa,GACzD,IAAKG,EAAoBG,KAAKD,GAC1B,MAKR,OAFAJ,EAAWM,OAAON,EAAWG,OAASJ,EAAYA,GAE3CC,MACV,EA1HyBlC,G,UCTxByC,EAAmC,GAmBlC,SAASC,IACZ,IAAMC,EAA4B,kBAArB,yCAAgC,CAAEC,IAAI,UAAD,8BAAaC,MAAM,UAAD,+BAAvD,wCACb,OAAO,SAACC,GACJL,EAAiBM,MAAjB,kBACOJ,GADP,IAEIG,KAAMA,EACNE,OAAQ,kBAAM,IAAIF,OCxB7BJ,EAAa,CACVE,IAAK,EACLC,MAAO,eAEX,4IAEI,WACI,IAAMI,EAAS5C,KAAK6B,WAAWgB,KAAI,SAAAC,GAAC,OAAIC,SAASD,MAGjD,OAFsBF,EAAOI,MAAM,GAAGC,QAAO,SAACC,EAAGJ,EAAGK,GAAP,OAAaD,GAAKN,EAAOO,GAAKL,EAAI,EAAI,KAAI,KAJ/F,mBASI,WACI,IAAMF,EAAS5C,KAAK6B,WAAWgB,KAAI,SAAAC,GAAC,OAAIC,SAASD,MAC3CM,EAAUR,EAAOI,MAAM,GAAGH,KAAI,SAACC,EAAGK,GAAJ,OAAUP,EAAOO,GAAKP,EAAOO,EAAI,GAAKL,KAG1E,OAFsBM,EAAQJ,MAAM,GAAGC,QAAO,SAACC,EAAGJ,EAAGK,GAAP,OAAaD,GAAKE,EAAQD,GAAKL,EAAI,EAAI,KAAI,OAZjG,GAA2BnD,IAApB,I,sBCFP,SAAS0D,EAAaC,EAAeC,GAIjC,IAHA,IACIC,EADEC,EAA6B,GAG3BD,EAASF,EAAMI,KAAKH,IACxBE,EAAQf,KAAKc,GAGjB,OAAOC,EAmBX,SAASE,EAAiBT,EAAWU,GACjC,OAAO,IAAIC,KAAI,OAAIX,GAAGY,QAAO,SAAAhB,GAAC,OAAIc,EAAEG,IAAIjB,OC7B3CT,EAAa,CACVE,IAAK,EACLC,MAAO,SAEX,4IAEI,WACI,IAAMwB,EAAM,CAAEC,IAAK,EAAGC,IAAK,GAM3B,OALAlE,KAAKmE,aAAaC,SAAQ,SAAAC,GACtBL,EAAIC,KAAOI,EAAQJ,IACnBD,EAAIE,KAAOG,EAAQH,OAGhBF,EAAIC,IAAMD,EAAIE,MAT7B,mBAYI,WACI,IAAMF,EAAM,CAAEC,IAAK,EAAGC,IAAK,EAAGI,IAAK,GAOnC,OANAtE,KAAKmE,aAAaC,SAAQ,SAAAC,GACtBL,EAAIM,KAAOD,EAAQH,IACnBF,EAAIC,KAAOI,EAAQJ,IACnBD,EAAIE,KAAOF,EAAIM,IAAMD,EAAQJ,OAG1BD,EAAIC,IAAMD,EAAIE,MApB7B,wBAuBI,WACI,OAAOb,EAAa,kBAAmBrD,KAAKG,OAAO0C,KAAI,SAAA0B,GACnD,cAAiCA,EAAjC,GAASC,EAAT,KAAqBC,EAArB,KACMC,EAAQ3B,SAAS0B,GACjBJ,EAAU,CAAEJ,IAAK,EAAGC,IAAK,GAC/B,OAAQM,GACJ,IAAK,UAAWH,EAAQJ,KAAOS,EAAO,MACtC,IAAK,OAAQL,EAAQH,KAAOQ,EAAO,MACnC,IAAK,KAAML,EAAQH,KAAOQ,EAAO,MACjC,QAAS,MAAM,IAAI/C,MAAM,kBAE7B,OAAO0C,SAlCnB,GAA2B1E,ICF1B0C,EAAa,CACVE,IAAK,EACLC,MAAO,qBAEX,4IAEI,WACI,IAAMmC,EAAgB3E,KAAK6B,WACrB+C,EAAYD,EAAc3C,OAAS,EACnC6C,EAAYF,EAAc,GAAG7C,MAAM,IAAIe,KAAI,SAACiC,EAAGC,GAAJ,OAC7CJ,EAAc1B,QAAO,SAACC,EAAG8B,GAAJ,OAAgB9B,EAAIH,SAASiC,EAAQD,MAAO,MAMrE,OAHchC,SAAS8B,EAAUhC,KAAI,SAAAC,GAAC,OAAIA,GAAK8B,EAAY,IAAM,OAAKK,KAAK,IAAK,GAChElC,SAAS8B,EAAUhC,KAAI,SAAAC,GAAC,OAAIA,EAAI8B,EAAY,IAAM,OAAKK,KAAK,IAAK,KAVzF,mBAeI,WACI,IAAMN,EAAgB3E,KAAK6B,WAI3B,OAH8B7B,KAAKkF,UAAUP,EAAe,eAClC3E,KAAKkF,UAAUP,EAAe,kBAlBhE,uBAuBI,SAAkBQ,EAAoBC,GAClC,IAAK,IAAIL,EAAM,EAAGA,EAAMI,EAAS,GAAGnD,QAER,KADxBmD,EAAWnF,KAAK8D,OAAOqB,EAAUJ,EAAKK,IACzBpD,OAF2B+C,KAK5C,OAAOhC,SAASoC,EAAS,GAAI,KA7BrC,oBAgCI,SAAeA,EAAoBE,EAAkBD,GACjD,IAAME,EAAWH,EAASlC,QAAO,SAACC,EAAGJ,GAAJ,OAAUI,EAAIH,SAASD,EAAEuC,MAAY,GAChEE,EAAcD,GAAYH,EAASnD,OAAS,KAAY,iBAAToD,GAA2B,IAAM,IAEtF,OAAOD,EAASrB,QAAO,SAAAhB,GAAC,OAAIA,EAAEuC,KAAcE,SApCpD,GAA2B5F,ICJ1B0C,EAAa,CACVE,IAAK,EACLC,MAAO,eAEX,4IAEI,WACI,OAAOxC,KAAKwF,UAAU,iBAH9B,mBAMI,WACI,OAAOxF,KAAKwF,UAAU,6BAP9B,uBAUI,SAAkBC,GAA8D,IAAD,SAC3E,EAAoCzF,KAAKmE,aAAjCuB,EAAR,EAAQA,QAASC,EAAjB,EAAiBA,OAAQC,EAAzB,EAAyBA,OACnBC,EAAuBF,EAAO9C,KAAI,kBAAMiD,MAlBpC,GAkBqDC,KAAK,GAAGlD,KAAI,kBAAMiD,MAlBvE,GAkBwFC,MAAK,SACjGC,EAAoB,IAAInC,IACxBoC,EAA8B,gBAAbR,EAA6B,EAAIE,EAAO3D,OAJY,UAMhD0D,GANgD,IAM3E,2BAAoC,CAAC,IAA1BQ,EAAyB,QAC1BC,EAAOP,EAAOQ,IAAIF,GACxB,GAAKC,EAAL,CAFgC,gBAIHA,GAJG,mCAInBE,EAJmB,EAInBA,GAAIC,EAJe,EAIfA,GAAIC,EAJW,EAIXA,GAGjB,IAFAV,EAAMQ,GAAIC,GAAIC,IAAM,GAEfP,EAAKjC,IAAIsC,IAAO,EAAKG,QAAQX,EAAMQ,GAAKC,EAAIC,MAC7CP,EAAKS,IAAIJ,GACLL,EAAKU,OAAST,GAKd,MAAM,CAAN,EAJYN,EAAOU,GAAIpD,QAAO,SAAC0D,EAAUC,EAAYC,GAAvB,OAC1BF,EAAWC,EAAW3D,QAAO,SAAC6D,EAAQC,EAASC,GAAlB,OACzBF,GAAUjB,EAAMQ,GAAIQ,GAAKG,GAAO,EAAID,KAAU,KAAI,GAE7Cb,IAVzB,2BAAmC,CAAC,IAAD,yCAJH,iCANuC,8BA0B3ElG,KAAKiH,eApCb,qBAuCI,SAAgBC,EAAoBC,EAAgBC,GAGhD,IAFA,IAAIP,GAAM,EACNG,GAAM,EACD7D,EAAI,EAAGA,EAhDN,EAgDqBA,IAG3B,GAFA0D,IAAAA,EAAQK,EAAM/D,GAAGiE,IACjBJ,IAAAA,EAAQE,EAAMC,GAAQhE,KACjB0D,IAAQG,EAAO,OAAO,EAG/B,OAAO,IAhDf,wBAmDI,WAMI,IANkB,IAAD,OACXtB,EAAU1F,KAAKqH,mBAAmBrH,KAAK6B,WAAW,IAClD8D,EAAuB,GACvBC,EAAS,IAAI0B,IAEfC,EAAY,EALC,aAWb,IAJA,IAAML,EAAoB,GACpBb,EAAKV,EAAOjD,KAAKwE,GAAS,EAE5BjF,OAAY,EAVH,aAYT,IAAM2E,EAAa,EAAKS,mBAAmBpF,GACrCqE,EAAKY,EAAMxE,KAAKkE,GAAc,EACpCA,EAAW/D,KAAI,SAAC2E,EAAGjB,GACf,IAAIkB,EAAc7B,EAAOQ,IAAIoB,GACxBC,GAAe7B,EAAO8B,IAAIF,EAAIC,EAAc,IACjDA,EAAY/E,KAAK,CAAE2D,GAAAA,EAAIC,GAAAA,EAAIC,GAAAA,QAN3BtE,EAAO,EAAKJ,aAAa0F,IAAc,KAL5CA,EAAYvH,KAAK6B,WAAWG,QAAS,IAgB5C,MAAO,CAAE0D,QAAAA,EAASC,OAAAA,EAAQC,OAAAA,KAzElC,gCA4EI,SAA2B3D,GACvB,OAAOoB,EAAa,OAAQpB,GAAMY,KAAI,SAAA0B,GAAK,OAAIxB,SAASwB,EAAM,WA7EtE,GAA2B5E,ICJ1B0C,EAAa,CACVE,IAAK,EACLC,MAAO,wBAEX,4IAEI,WACI,IAAMmF,EAAQ3H,KAAK4H,aACb/E,EAAM7C,KAAK6H,UAAUF,EAAO,kBAGlC,OAFqB3H,KAAK8H,cAAcjF,KALhD,mBAUI,WACI,IAAM8E,EAAQ3H,KAAK4H,aACb/E,EAAM7C,KAAK6H,UAAUF,EAAO,qBAGlC,OAFqB3H,KAAK8H,cAAcjF,KAbhD,2BAkBI,SAAsBA,GAClB,OAAOA,EAAII,QAAO,SAACC,EAAG2D,GAAJ,OAAY3D,EAAI2D,EAAI5D,QAAO,SAACC,EAAGJ,GAAJ,OAAUI,GAAKJ,EAAI,EAAI,EAAI,KAAI,KAAI,KAnBxF,uBAsBI,SAAkB6E,EAAeI,GAC7B,IADuF,EACjFlF,EAAkB,GAClBmF,EAAyB,mBAATD,EAFiE,UAGtDJ,GAHsD,IAGvF,2BAAwC,CAAC,IAAD,UAA3BM,EAA2B,EAA3BA,GAAIC,EAAuB,EAAvBA,GAAIC,EAAmB,EAAnBA,GAAIC,EAAe,EAAfA,GACjBJ,GAAiBC,IAAOE,GAAMD,IAAOE,GAGzCpI,KAAKqI,SAASxF,EAAKoF,EAAIC,EAAIC,EAAIC,IAPoD,8BAUvF,OAAOvF,IAhCf,sBAmCI,SAAiBA,EAAiBoF,EAAYC,EAAYC,EAAYC,GAKlE,IAJA,IAAME,EAAKC,KAAKC,KAAKL,EAAKF,GACpBQ,EAAKF,KAAKC,KAAKJ,EAAKF,GAE1B,UAAa,CAAC,KAAM,MAApB,GAAKpF,EAAL,KAAQ4F,EAAR,KACO5F,IAAMqF,GAAMO,IAAMN,GAAI,CAAC,IAAD,IACzBtF,GAAI,UAACA,SAAD,QAAMmF,EAAKK,GAAMA,OAGNrI,IAAX4C,EAFJ6F,GAAI,UAACA,SAAD,QAAMR,EAAKO,GAAMA,KAEO5F,EAAI6F,GAAK,SACnBzI,IAAd4C,EAAI6F,GAAG5F,KAAoBD,EAAI6F,GAAG5F,GAAK,GAC3CD,EAAI6F,GAAG5F,QA9CnB,wBAkDI,WACI,OAAOO,EAAa,8BAA+BrD,KAAKG,OAAO0C,KAAI,SAAA0B,GAC/D,MAAyBA,EAAMvB,MAAM,GAAGH,KAAI,SAAAC,GAAC,OAAIC,SAASD,MAA1D,eACA,MAAO,CAAEmF,GADT,KACaC,GADb,KACiBC,GADjB,KACqBC,GADrB,aApDZ,GAA2BzI,ICH1B0C,EAAa,CACVE,IAAK,EACLC,MAAO,eAEX,4IAEI,WACI,OAAOxC,KAAK2I,oBAAoB,MAHxC,mBAMI,WACI,OAAO3I,KAAK2I,oBAAoB,OAPxC,iCAUI,SAA4BC,GACxB,IAAMC,EAAiB/C,MAAMgD,GAAgB/C,KAAK,GACnC1C,EAAa,MAAOrD,KAAKG,OAAO0C,KAAI,SAAAC,GAAC,OAAIC,SAASD,EAAE,OAC5DsB,SAAQ,SAAAtB,GAAC,OAAI+F,EAAK/F,QAEzB,IAAK,IAAIP,EAAM,EAAGA,EAAMqG,EAAUrG,IAAO,CACrC,IAAMwG,EAAQF,EAAKG,QACnBH,EAvBO,GAuBYE,EACnBF,EAzBO,IAyBaE,EAIxB,OADmBF,EAAK5F,QAAO,SAACC,EAAGJ,GAAJ,OAAUI,EAAIJ,IAAG,OArBxD,GAA2BnD,ICP1B0C,EAAa,CACVE,IAAK,EACLC,MAAO,2BAEX,4IAEI,WAII,IAHA,MAAkCxC,KAAKmE,aAA/B8E,EAAR,EAAQA,MAAOC,EAAf,EAAeA,OAAQC,EAAvB,EAAuBA,OAEnBC,EAAWC,OAAOC,UAHA,WAIbC,GACL,IAAMC,EAAQP,EAAMhG,QAAO,SAACC,EAAGJ,GAAJ,OAAUI,EAAIqF,KAAKkB,IAAI3G,EAAIyG,KAAS,GAC/DH,EAAWb,KAAKmB,IAAIN,EAAUI,IAFzBD,EAASL,EAAQK,GAAUJ,EAAQI,IAAW,EAA9CA,GAKT,OAAOH,IAXf,mBAcI,WAII,IAHA,MAAkCpJ,KAAKmE,aAA/B8E,EAAR,EAAQA,MAAOC,EAAf,EAAeA,OAAQC,EAAvB,EAAuBA,OAEnBC,EAAWC,OAAOC,UAHA,WAIbC,GACL,IAAMC,EAAQP,EAAMhG,QAAO,SAACC,EAAGJ,GAC3B,IAAM6G,EAAQpB,KAAKkB,IAAI3G,EAAIyG,GAE3B,OAAOrG,EADMyG,GAASA,EAAQ,GAAK,IAEpC,GACHP,EAAWb,KAAKmB,IAAIN,EAAUI,IANzBD,EAASL,EAAQK,GAAUJ,EAAQI,IAAW,EAA9CA,GAST,OAAOH,IA3Bf,wBA8BI,WACI,IAAIF,EAASG,OAAOC,UAChBH,EAASE,OAAOO,UASpB,MAAO,CAAEX,MAPK5F,EAAa,OAAQrD,KAAKG,OAAO0C,KAAI,SAAAC,GAC/C,IAAMiC,EAAMhC,SAASD,EAAE,IAGvB,OAFAoG,EAASX,KAAKmB,IAAIR,EAAQnE,GAC1BoE,EAASZ,KAAKsB,IAAIV,EAAQpE,GACnBA,KAGKmE,OAAAA,EAAQC,OAAAA,OAzChC,GAA2BxJ,ILApB,I,8CMCDmK,EAAmC,CAAC,SAAU,KAAM,QAAS,QAAS,OAAQ,QAAS,SAAU,MAAO,UAAW,UACnHC,EAAuC,IAAIlG,IAAIiG,GCJ/CE,GDML3H,EAAa,CACVE,IAAK,EACLC,MAAO,wBAEX,4IAEI,WACI,IAAMyH,EAAgB,IAAIpG,IAAI,CAAC,EAAG,EAAG,EAAG,IAKxC,OAJiB7D,KAAKmE,aACOlB,QAAO,SAACC,EAAGgH,GAAJ,OAAUhH,EAC1CgH,EAAEC,OAAOlH,QAAO,SAACC,EAAGkH,GAAJ,OAAUlH,GAAK+G,EAAclG,IAAIqG,EAAEpI,QAAU,EAAI,KAAI,KAAI,KANrF,mBAWI,WAA2B,IAAD,OAChBqI,EAAWrK,KAAKmE,aAMtB,OALYkG,EAASpH,QAAO,SAACC,EAAGoH,EAASnH,GAErC,OADA,EAAKoH,eAAepH,EAAIkH,EAASrI,QAC1BkB,EAAI,EAAKsH,mBAAmBF,KACpC,KAhBX,gCAsBI,YAAmE,IAAD,OAArCG,EAAqC,EAArCA,SAAUN,EAA2B,EAA3BA,OAC7BO,EAAkB1K,KAAK2K,wBAAwBF,GAC/CG,EAAa5K,KAAK6K,kBAAkBH,EAAiBD,GAI3D,OAHKG,GAAc5K,KAAKiH,aAEHlE,SAASoH,EAAOtH,KAAI,SAAAC,GAAC,OAAI,EAAKgI,YAAYhI,EAAG8H,MAAa3F,KAAK,OA3B5F,+BAgCI,SAA0B8F,EAA2BN,GAAmD,IAAD,OAA9BO,EAA8B,uDAAtB,EAC7E,GAAIA,IAAUD,EAAS/I,OAAQ,CAC3B,IAAMiJ,EAAeC,OAAOC,YAAYJ,EAASlI,KAAI,SAAAC,GAAC,MAAI,CAACA,EAAEsI,KAAMtI,EAAEuI,GAAG,QACxE,OAAOrL,KAAKsL,kBAAkBL,EAAcR,GAAYQ,EAAe,KAG3E,IANmG,EAM7FM,EAAiBR,EAASC,GAAOK,GAN4D,UAOxEE,GAPwE,yBAOxFC,EAPwF,QAQzFC,EAAO,kBACNV,EAAS/H,MAAM,EAAGgI,IADZ,CAET,CAAEI,KAAML,EAASC,GAAOI,KAAMC,GAAI,CAACG,MAF1B,OAGNT,EAAS/H,MAAMgI,EAAQ,GAAGnI,KAAI,SAAAC,GAAC,MAAK,CACnCsI,KAAMtI,EAAEsI,KACRC,GAAIvI,EAAEuI,GAAGvH,QAAO,SAAA4H,GAAC,OAAIA,IAAMF,WAI7BjM,EAAS,EAAKsL,kBAAkBY,EAAShB,EAAUO,EAAQ,GACjE,GAAIzL,EAAU,MAAM,CAAN,EAAOA,IAXzB,2BAA2C,CAAC,IAAD,yCAPwD,8BAqBnG,OAAO,OArDf,+BAyDI,SAA0BsD,EAAiB4H,GAA8B,IAAD,OACpE,OAAOA,EAASkB,OAAM,SAAAC,GAAC,OAAI7B,EAAgBhG,IAAI,EAAK8H,eAAeD,EAAG/I,SA1D9E,yBA8DI,SAAoBiJ,EAAkBjJ,GAClC,OAAOiH,EAAciC,QAAQ/L,KAAK6L,eAAeC,EAAUjJ,MA/DnE,4BAmEI,SAAuBiJ,EAAkBjJ,GACrC,OAAOiJ,EAAShK,MAAM,IAAIe,KAAI,SAAAC,GAAC,OAAID,EAAIC,MAAIkJ,OAAO/G,KAAK,MApE/D,qCAwEI,SAAgCwF,GAC5B,IAAMwB,EAAyB,IAAI3E,IAAwBxB,MAAM,GAAGC,KAAK,GAAGlD,KAAI,SAACiC,EAAG3B,GAAJ,MAAU,CAACA,EAAG,QAC9F2G,EAAc1F,SAAQ,SAAAtB,GAAC,OAAImJ,EAAuB7F,IAAItD,EAAEd,QAASU,KAAKI,EAAEhB,MAAM,QAE9E,IAJiE,EAI3DoK,EAAY,IAAI5E,IAJ2C,UAK3CmD,GAL2C,yBAKtD0B,EALsD,QAOvDC,EAAa,IAAI9E,IACjB+E,EAAcJ,EAAuB7F,IAAI+F,EAAQnK,QACvDmK,EAAQrK,MAAM,IAAIsC,SAAQ,SAAAkI,GAAW,OACjCD,EAAYjI,SAAQ,SAAAmI,GAAE,OAAIA,EAAGnI,SAAQ,SAAAoI,GAC5BJ,EAAWrI,IAAIuI,IAAgBF,EAAW1E,IAAI4E,EAAa,IAAIzI,KACpEuI,EAAWhG,IAAIkG,GAAc7F,IAAI+F,YAZoB,gBAiB/BJ,EAAWK,WAjBoB,IAiB7D,2BAAoD,CAAC,IAAD,qBAAxCC,EAAwC,KAAnCC,EAAmC,KAChD,GAAKT,EAAUnI,IAAI2I,GAEZ,CACH,IAAME,EAAeV,EAAU9F,IAAIsG,GACnCR,EAAUxE,IAAIgF,EAAK/I,EAAciJ,EAAcD,SAH/CT,EAAUxE,IAAIgF,EAAKC,IAnBkC,gCAKjE,2BAAiC,IALgC,8BA4BjE,OAAO,OAAIT,EAAUO,WAChB5J,KAAI,SAAAC,GAAC,MAAK,CAAEsI,KAAMtI,EAAE,GAAIuI,IAAG,OAAKvI,EAAE,QAClCkJ,MAAK,SAAC9I,EAAGU,GAAJ,OAAUV,EAAEmI,GAAGrJ,OAAS4B,EAAEyH,GAAGrJ,YAtG/C,wBAyGI,WAQI,OAPiBqB,EAAa,gBAAiBrD,KAAKG,OAAO0C,KAAI,SAAAgK,GAC3D,cAAmCA,EAAnC,GAASC,EAAT,KAAsBC,EAAtB,KAGA,MAAO,CAAEtC,SAFQpH,EAAa,UAAWyJ,GAAajK,KAAI,SAAAC,GAAC,OAAIA,EAAE,MAE9CqH,OADJ9G,EAAa,UAAW0J,GAAWlK,KAAI,SAAAC,GAAC,OAAIA,EAAE,cA7GzE,GAA2BnD,ICVS,CAAC,EAAE,EAAG,GAAI,CAAC,GAAI,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,IAAIkD,KAAI,SAAA+I,GAAC,MAAK,CAAE9I,EAAG8I,EAAE,GAAIlD,EAAGkD,EAAE,QCH3FoB,IDKL3K,EAAa,CACVE,IAAK,EACLC,MAAO,eAEX,4IAEI,WACI,IAAMyK,EAAYjN,KAAKmE,aAIvB,OAHkBnE,KAAKkN,aAAaD,GACdhK,QAAO,SAACC,EAAG0I,GAAJ,OAAU1I,EAAI,EAAI+J,EAAUpK,IAAI+I,EAAElD,GAAGkD,EAAE9I,KAAI,KALhF,mBAUI,WAA2B,IAAD,OAChBmK,EAAYjN,KAAKmE,aAMvB,OALkBnE,KAAKkN,aAAaD,GACXpK,KAAI,SAAA+I,GAAC,OAAI,EAAKuB,MAAMF,EAAWrB,MAC1BI,MAAK,SAAC9I,EAAGU,GAAJ,OAAUA,EAAIV,KAAGF,MAAM,EAAG,GAC9BC,QAAO,SAACC,EAAGJ,GAAJ,OAAUI,EAAIJ,IAAG,KAf/D,0BAoBI,YAEI,IAF8D,IAA3CD,EAA0C,EAA1CA,IAAKuK,EAAqC,EAArCA,MAAOC,EAA8B,EAA9BA,OACzBC,EAAqB,GADkC,WAEpD5E,GACL,IAHyD,eAGhD5F,GACL,IAAMtB,EAAUqB,EAAI6F,GAAG5F,GACJkH,EACdnH,KAAI,SAAA0K,GAAE,OAAI1K,EAAI6F,EAAI6E,EAAG7E,IAAM7F,EAAI6F,EAAI6E,EAAG7E,GAAG5F,EAAIyK,EAAGzK,MAChD6I,OAAM,SAAAnE,GAAC,YAAUvH,IAANuH,GAAmBhG,EAAUgG,MAEzC8F,EAAU5K,KAAK,CAAEI,EAAAA,EAAG4F,EAAAA,KANnB5F,EAAI,EAAGA,EAAIsK,EAAOtK,IAAM,EAAxBA,IADJ4F,EAAI,EAAGA,EAAI2E,EAAQ3E,IAAM,EAAzBA,GAYT,OAAO4E,IAlCf,mBAyCI,WAAiDrM,GAK7C,IALoE,IAAxD4B,EAAuD,EAAvDA,IAAKuK,EAAkD,EAAlDA,MAAOC,EAA2C,EAA3CA,OAElBG,EAAiB,IAAI3J,IACrB4J,EAAiB,CAACxM,GAH2C,aAM/D,IALa2K,EAKP8B,EAAQD,EAAMzE,QACd2E,GANO/B,EAMc8B,GANChF,EAAI0E,EAAQxB,EAAE9I,EAQ1C,GAAI0K,EAAezJ,IAAI4J,GAAe,iBACtCH,EAAe/G,IAAIkH,GAEnB3D,EAAU5F,SAAQ,SAAAmJ,GACd,IAAMK,EAAQF,EAAM5K,EAAIyK,EAAGzK,EACrB+K,EAAQH,EAAMhF,EAAI6E,EAAG7E,EACvBkF,GAAS,GAAKA,EAAQR,GACtBS,GAAS,GAAKA,EAAQR,GACtBxK,EAAIgL,GAAOD,GAAS,GAEpBH,EAAM/K,KAAK,CAAEI,EAAG8K,EAAOlF,EAAGmF,QAd/BJ,EAAMzL,OAAS,GAAG,IAmBzB,OAAOwL,EAAe9G,OAjE9B,wBAoEI,WACI,IAAM7D,EAAM7C,KAAK6B,WAAWgB,KAAI,SAAAZ,GAAI,OAChCoB,EAAa,MAAOpB,GAAMY,KAAI,SAAAC,GAAC,OAAIC,SAASD,EAAE,UAGlD,MAAO,CACHD,IAAAA,EACAuK,MAAOvK,EAAI,GAAGb,OACdqL,OAAQxK,EAAIb,YA5ExB,GAA2BrC,ICTR,CAAE,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,MAClDmO,GAAc,CAAE,IAAK,EAAG,IAAK,GAAI,IAAK,KAAM,IAAK,OACjDC,GAAiB,CAAE,IAAK,EAAG,IAAK,EAAG,IAAK,EAAG,IAAK,GCDhDC,IDGL3L,EAAa,CACVE,IAAK,GACLC,MAAO,kBAEX,4IAEI,WAA2B,IAAD,OAEtB,OADmBxC,KAAK6B,WAAWoB,QAAO,SAACC,EAAG+K,GAAJ,OAAU/K,EAAI,EAAKgL,MAAMD,EAAG,WAAU,KAHxF,mBAOI,WAA2B,IAAD,OAEhBE,EADkBnO,KAAK6B,WAAWiC,QAAO,SAAAmK,GAAC,OAAK,EAAKC,MAAMD,EAAG,YAC5BpL,KAAI,SAAAoL,GAAC,OAAI,EAAKC,MAAMD,EAAG,eAG9D,OAFoBE,EAAenC,MAAK,SAAC9I,EAAGU,GAAJ,OAAUV,EAAIU,KAAG2E,KAAK6F,MAAMD,EAAenM,OAAS,MAVpG,mBAeI,SAAcC,EAAc8F,GACxB,IAD4D,EACtDsG,EAAQ,GAD8C,UAEvCpM,EAAKH,MAAM,KAF4B,IAE5D,2BAAqC,CAAC,IAA3BwM,EAA0B,QACjC,GAAItB,GAAWsB,GACXD,EAAM3L,KAAK4L,OACR,CACH,IAAMC,EAAaF,EAAMG,MAEzB,GADiBxB,GAAWuB,KACXD,EACb,OAAOR,GAAYQ,KAT6B,8BAc5D,IAAIJ,EAAQ,EAKZ,MAJa,aAATnG,IACAmG,EAAQG,EAAMI,aAAY,SAACvL,EAAGJ,GAAJ,OAAc,EAAJI,EAAQ6K,GAAef,GAAWlK,MAAK,IAGxEoL,MAlCf,GAA2BvO,IEL1B0C,EAAa,CACVE,IAAK,GACLC,MAAO,iBAEX,4IAEI,WAGI,IAFA,IAAMkM,EAAO1O,KAAKmE,aACdwK,EAAa,EACRC,EAAO,EAAGA,GAAQ,IAAKA,IAC5BD,GAAc3O,KAAK4O,KAAKF,GAG5B,OAAOC,IATf,mBAYI,WAII,IAHA,IAAMD,EAAO1O,KAAKmE,aACZ0K,EAAyBH,EAAKtB,MAAQsB,EAAKrB,OAC7CuB,EAAO,EACJ5O,KAAK4O,KAAKF,GAAQG,GACrBD,IAGJ,OAAOA,IApBf,kBAuBI,SAAaF,GAAqB,IAAD,OACrB7L,EAAQ6L,EAAR7L,IACJ8L,EAAa,EAKjB,OAJA3O,KAAK8O,YAAYJ,GAAM,SAAC5L,EAAG4F,GAAJ,OAAU7F,EAAI6F,GAAG5F,QACxC9C,KAAK8O,YAAYJ,GAAM,SAAC5L,EAAG4F,GAAJ,OAAUiG,GAAc,EAAKI,MAAML,EAAM5L,EAAG4F,MACnE1I,KAAK8O,YAAYJ,GAAM,SAAC5L,EAAG4F,GAAJ,OAAU7F,EAAI6F,GAAG5F,GAAKyF,KAAKsB,IAAI,EAAGhH,EAAI6F,GAAG5F,OAEzD6L,IA9Bf,mBAiCI,SAAcD,EAAY5L,EAAW4F,GAAoB,IAAD,OAC5C7F,EAAQ6L,EAAR7L,IACR,GAAIA,EAAI6F,GAAG5F,IAAM,EAAK,OAAO,EAE7B,IAAI6L,EAAa,EASjB,OARA9L,EAAI6F,GAAG5F,GAAKuG,OAAO2F,iBACnBhP,KAAKiP,gBAAgBP,EAAM5L,EAAG4F,GAAG,SAACwG,EAAIC,GAClCtM,EAAIsM,GAAID,KACJrM,EAAIsM,GAAID,GAAM,IACdP,GAAc,EAAKI,MAAML,EAAMQ,EAAIC,OAIpCR,IA9Cf,yBAiDI,WAA6CS,GACzC,IADwF,IAAtEhC,EAAqE,EAArEA,MAAOC,EAA8D,EAA9DA,OAChB3E,EAAI,EAAGA,EAAI2E,EAAQ3E,IACxB,IAAK,IAAI5F,EAAI,EAAGA,EAAIsK,EAAOtK,IACvBsM,EAAOtM,EAAG4F,KApD1B,6BAyDI,WAAiD2G,EAAgBC,EAAgBF,GAG7E,IAH4H,IAAtGhC,EAAqG,EAArGA,MAAOC,EAA8F,EAA9FA,OACvBkC,EAAOhH,KAAKmB,IAAI0D,EAAQ,EAAGiC,EAAS,GACpCG,EAAOjH,KAAKmB,IAAI2D,EAAS,EAAGiC,EAAS,GAClC5G,EAAIH,KAAKsB,IAAI,EAAGyF,EAAS,GAAI5G,GAAK8G,EAAM9G,IAC7C,IAAK,IAAI5F,EAAIyF,KAAKsB,IAAI,EAAGwF,EAAS,GAAIvM,GAAKyM,EAAMzM,IACzCA,IAAMuM,GAAU3G,IAAM4G,GAC1BF,EAAOtM,EAAG4F,KA/D1B,uBAoEI,YAAwC,IAC9B+G,EAD6B,EAAnB5M,IAEXA,KAAI,SAAAZ,GAAI,OAAIA,EAAKY,KAAI,SAAAC,GAAC,OAAIA,EAAI,EAAI,IAAMA,EAAI,EAAI,IAAMA,KAAGmC,KAAK,OAC9DA,KAAK,MACVyK,QAAQC,IAAR,YAAiBF,MAxEzB,wBA2EI,WAA4B,IAAD,IACjB5M,EAAMQ,EAAa,OAAQrD,KAAKG,OAAO0C,KAAI,SAAA+M,GAAS,OACtDA,EAAU,GAAG9N,MAAM,IAAIe,KAAI,SAAAC,GAAC,OAAIC,SAASD,SAG7C,MAAO,CAAED,IAAAA,EAAKuK,MAAK,oBAAEvK,EAAI,UAAN,aAAE,EAAQb,cAAV,QAAoB,EAAGqL,OAAQxK,EAAIb,YAhF9D,GAA2BrC,ICJ1B0C,EAAa,CACVE,IAAK,GACLC,MAAO,mBAEX,4IAEI,WACI,OAAOxC,KAAK6P,cAAc7P,KAAK8P,kBAAmB,KAH1D,mBAMI,WACI,OAAO9P,KAAK6P,cAAc7P,KAAK8P,qBAPvC,2BAUI,SAAsBC,GAA4F,IAApEC,EAAmE,uDAApD,EAAGxO,EAAiD,uCAA/ByO,EAA+B,uCACrGpN,EAAoBkN,EAApBlN,IAAK5B,EAAe8O,EAAf9O,MAAOiP,EAAQH,EAARG,IACpB,IAAK1O,IAAYyO,EACb,OAAOjQ,KAAK6P,cAAcE,EAAYC,EAAc/O,EAAO,IAAI4C,IAAI,CAAC5C,KAGxE,IAN6G,EAMzGkP,EAAY,EACVC,EAAUvN,EAAIuD,IAAI5E,GAPqF,UAQ1F4O,GAR0F,IAQ7G,2BAA4B,CAAC,IAAlB/O,EAAiB,QACxB,GAAIA,IAASJ,EAAb,CAEA,IAAIoP,EAAmBL,EACvB,GAAI3O,EAAO,GAAK4O,EAAQlM,IAAI1C,GAAO,CAC/B,GAAIgP,EAAoB,SACxBA,EAAmBhP,EAGvB4O,EAAQxJ,IAAIpF,GACRA,IAAS6O,EACTC,IAEAA,GAAanQ,KAAK6P,cAAcE,EAAYM,EAAkBhP,EAAM4O,GAEpEI,IAAqBhP,GAAQ4O,EAAQK,OAAOjP,KAvByD,8BA0B7G,OAAO8O,IApCf,6BAwCI,WACI,IADkC,EAC9BI,EAAY,EACVC,EAAcnN,EAAa,eAAgBrD,KAAKG,OAAO0C,KAAI,qCAAc,CAAd,cAC3D4N,GAAK,OAAO,IAAI5M,IAAI2M,EAAYE,SAChCC,EAAUzF,OAAOC,YAAYsF,EAAM5N,KAAI,SAAA6I,GAAC,MAAI,CAACA,IAAK6E,GAAa7E,EAAE,GAAGkF,gBAAkBlF,EAAE,GAAK,GAAK,QAClG7I,EAAM,IAAIyE,IAAsBmJ,EAAM5N,KAAI,SAAAC,GAAC,MAAI,CAAC6N,EAAQ7N,GAAI,QALhC,UAMb0N,GANa,IAMlC,2BAAkC,CAAC,IAAD,qBAAtBtN,EAAsB,KAAnBU,EAAmB,KAC9Bf,EAAIuD,IAAIuK,EAAQzN,IAAKR,KAAKiO,EAAQ/M,IAClCf,EAAIuD,IAAIuK,EAAQ/M,IAAKlB,KAAKiO,EAAQzN,KARJ,8BAWlC,MAAO,CAAEL,IAAAA,EAAK5B,MAAO0P,EAAO,MAAWT,IAAKS,EAAO,SAnD3D,GAA2BhR,ICH1B0C,EAAa,CACVE,IAAK,GACLC,MAAO,uBAEX,mMACchD,uBADd,wCAGI,WACI,IAAMqR,EAAS7Q,KAAKmE,aAGpB,OAFenE,KAAK8Q,KAAKD,EAAOE,OAAQF,EAAOG,MAAM,IAEvChP,SAPtB,mBAUI,WAA2B,IAAD,OACtBhC,KAAKR,kBAAoB,CAAEyR,MAAO,IAClC,IAAMJ,EAAS7Q,KAAKmE,aACd4M,EAASF,EAAOG,MAAM/N,QAAO,SAAC8N,EAAQD,GAExC,OADA,EAAKtR,kBAAmByR,MAAMvO,KAAK,CAAEqO,OAAAA,EAAQD,KAAAA,IACtC,EAAKA,KAAKC,EAAQD,KAC1BD,EAAOE,QAIV,OAHA/Q,KAAKR,kBAAmByR,MAAMvO,KAAK,CAAEqO,OAAAA,IACxB/Q,KAAKkR,KAAKH,KAlB/B,kBAuBI,SAAaA,EAAiBD,GAC1B,IAAMK,EAAa,IAAItN,IASvB,OARqBkN,EAAOlO,KAAI,SAAA+I,GAAC,MAAK,CAClC9I,EAAGgO,EAAKhO,GAAK8I,EAAE9I,EAAIgO,EAAKhO,EAAI8I,EAAE9I,EAAqB,GAAhB8I,EAAE9I,EAAIgO,EAAKhO,GAAS8I,EAAE9I,EACzD4F,EAAGoI,EAAKpI,GAAKkD,EAAElD,EAAIoI,EAAKpI,EAAIkD,EAAElD,EAAqB,GAAhBkD,EAAElD,EAAIoI,EAAKpI,GAASkD,EAAElD,MACzD5E,QAAO,SAAA8H,GACP,IAAMwF,EAAQ,UAAMxF,EAAE9I,EAAR,YAAa8I,EAAElD,GAC7B,OAAOyI,EAAWpN,IAAIqN,IAAoBD,EAAW1K,IAAI2K,QA9BrE,kBAoCI,SAAaL,GACT,IAAM3D,EAAQ2D,EAAO9N,QAAO,SAACC,EAAG0I,GAAJ,OAAUrD,KAAKsB,IAAI3G,EAAG0I,EAAE9I,MAAK,GAAK,EACxDuK,EAAS0D,EAAO9N,QAAO,SAACC,EAAG0I,GAAJ,OAAUrD,KAAKsB,IAAI3G,EAAG0I,EAAElD,MAAK,GAAK,EACzD2I,EAAQvL,MAAMuH,GAAQtH,KAAK,GAAGlD,KAAI,kBAAMiD,MAAMsH,GAAOrH,KAAK,QAGhE,OAFAgL,EAAO3M,SAAQ,SAAAwH,GAAC,OAAIyF,EAAMzF,EAAElD,GAAGkD,EAAE9I,GAAK,YAE/BuO,EAAMxO,KAAI,SAAAZ,GAAI,OAAIA,EAAKgD,KAAK,OAAKA,KAAK,QA1CrD,wBA6CI,WAYI,MAAO,CAAE8L,OAXM1N,EAAa,eAAgBrD,KAAKG,OAAO0C,KAAI,SAAAyO,GAAC,MAAK,CAAExO,EAAGC,SAASuO,EAAE,IAAK5I,EAAG3F,SAASuO,EAAE,QAWpFN,MAVH3N,EAAa,2BAA4BrD,KAAKG,OACvD0C,KAAI,SAAAyO,GACD,IAAMC,EAAOD,EAAE,GACTvM,EAAMhC,SAASuO,EAAE,IACvB,MAAO,CACHxO,EAAY,MAATyO,EAAexM,EAAM,EACxB2D,EAAY,MAAT6I,EAAexM,EAAM,WArD5C,GAA2BpF,ICL1B0C,EAAa,CACVE,IAAK,GACLC,MAAO,2BAEX,4IAEI,WACI,MAA4BxC,KAAKmE,aAAzBqN,EAAR,EAAQA,SAAUC,EAAlB,EAAkBA,MAClB,EAA8CzR,KAAK0R,SAASF,EAAUC,EAAO,IAArEE,EAAR,EAAQA,iBAER,OAFA,EAA0BC,gBAEDD,IANjC,mBASI,WACI,MAA4B3R,KAAKmE,aAAzBqN,EAAR,EAAQA,SAAUC,EAAlB,EAAkBA,MAClB,EAA8CzR,KAAK0R,SAASF,EAAUC,EAAO,IAArEE,EAAR,EAAQA,iBAER,OAFA,EAA0BC,gBAEDD,IAbjC,sBAgBI,SAAiBH,EAAkBC,EAAeI,GAC9C,IAAMC,GAAO,OAAO,IAAIjO,IAAI4N,EAAMM,SAAQ,SAAAjP,GAAC,OAAKA,EAAEkP,WAAP,eAAqBlP,EAAEmP,KAAKnQ,MAAM,WACvEoQ,EAAehH,OAAOC,YAAY2G,EAAQjP,KAAI,SAAAC,GAAC,MAAI,CAACA,EAAG,OACvDqP,EAAmBL,EAAQC,SAAQ,SAAA7O,GAAC,OAAI4O,EAAQjP,KAAI,SAAAe,GAAC,OAAIV,EAAIU,QAC7DwO,EAAalH,OAAOC,YAAYgH,EAAiBtP,KAAI,SAAAC,GAAC,MAAI,CAACA,EAAG,OAC9DuP,EAAUnH,OAAOC,YAAYsG,EAAM5O,KAAI,SAAAyP,GAAI,MAAK,CAACA,EAAKL,KAAMK,OAGlEd,EAAS1P,MAAM,IAAIsC,SAAQ,SAACmO,EAAMpP,EAAGqP,GACjCN,EAAaK,KACTpP,EAAIqP,EAAcxQ,OAAS,GAC3BoQ,EAAWG,EAAOC,EAAcrP,EAAI,SAK5C,IAAK,IAAIyL,EAAO,EAAGA,EAAOiD,EAAWjD,IACjC,IAD0C,IAAD,aACpC,sBAAOqD,EAAP,KAAalJ,EAAb,KACD,EAAgCsJ,EAAQJ,GAAhCQ,EAAR,EAAQA,SAAUT,EAAlB,EAAkBA,UAClBE,EAAaF,IAAcjJ,EAC3BqJ,EAAWH,IAASlJ,EACpB0J,EAASrO,SAAQ,SAAAsO,GAAO,OAAIN,EAAWM,IAAY3J,MAJvD,MAA4BmC,OAAOuB,QAAQ2F,GAA3C,eAAyD,IAS7D,IAAMO,EAAwBzH,OAAOuB,QAAQyF,GACxCrP,KAAI,qCAAoB,CAAE0P,KAAtB,KAA4BxJ,MAA5B,SACJiD,MAAK,SAAC9I,EAAGU,GAAJ,OAAUV,EAAE6F,MAAQnF,EAAEmF,SAC1B4I,EAAmBgB,EAAsB,GAAG5J,MAGlD,MAAO,CAAE6I,gBAFee,EAAsBA,EAAsB3Q,OAAS,GAAG+G,MAEtD4I,iBAAAA,KAhDlC,wBAmDI,WAAsB,IAAD,IASjB,MAAO,CAAEH,SARK,oBAAGxR,KAAKG,MAAMoE,MAAM,gBAApB,aAAG,EAA4B,UAA/B,QAAqC,GAQhCkN,MAPLpO,EAAa,mBAAoBrD,KAAKG,OAC/C0C,KAAI,+BAAIoP,EAAJ,KAAUD,EAAV,WAA0B,CAC3BC,KAAAA,EACAD,UAAAA,EACAS,SAAU,CAACR,EAAK,GAAKD,EAAWA,EAAYC,EAAK,aAzDjE,GAA2BtS,IJNrBqO,WACF,WAAmBlL,EAAkB4F,IAAY,oBAA9B5F,EAAAA,EAA6B,KAAX4F,EAAAA,EAGe,OAHD,2BACnD,SAAIkK,GAAuB,OAAO,IAAI5E,EAAMhO,KAAK8C,EAAI8P,EAAM9P,EAAG9C,KAAK0I,EAAIkK,EAAMlK,KAAK,wBAClF,SAAW0E,EAAeC,GAAkB,OAAOrN,KAAK8C,GAAK,GAAK9C,KAAK8C,EAAIsK,GAASpN,KAAK0I,GAAK,GAAK1I,KAAK0I,EAAI2E,IAAS,sBACrH,WAAqB,MAAM,GAAN,OAAUrN,KAAK8C,EAAf,YAAoB9C,KAAK0I,OAAM,EAJlDsF,IAOA6E,GAA+B,CAAC,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,EAAE,EAAG,GAAI,CAAC,GAAI,IAAIhQ,KAAI,+BAAEC,EAAF,KAAK4F,EAAL,YAAY,IAAIsF,GAAMlL,EAAG4F,M,IAEpGrG,EAAa,CACVE,IAAK,GACLC,MAAO,UAEX,4IAEI,WACI,IAAMkM,EAAO1O,KAAK8S,YAGlB,OAFiB9S,KAAK+S,uBAAuBrE,KAJrD,mBASI,WACI,IAAMA,EAAO1O,KAAKgT,YAAYhT,KAAK8S,YAAa,GAGhD,OAFiB9S,KAAK+S,uBAAuBrE,KAXrD,oCAgBI,SAA+BA,GAwB3B,IAvBA,IAAQ7L,EAAuB6L,EAAvB7L,IAAKuK,EAAkBsB,EAAlBtB,MAAOC,EAAWqB,EAAXrB,OACdrL,EAASoL,EAAQC,EAIjB4F,EAAWjR,EAAS,EAEpBkR,EAAQpN,MAAM9D,GAAQ+D,KAAK,GAAGlD,KAAI,SAACiC,EAAG3B,GACxC,IAAMyI,EALM,SAACzI,GAAD,OAAe,IAAI6K,GAAM7K,EAAIiK,EAAO7E,KAAK6F,MAAMjL,EAAIiK,IAKrD+F,CAAQhQ,GACZiQ,EAAmBP,GAAWhQ,KAAI,SAAAuH,GAAC,OACrCwB,EAAEnF,IAAI2D,GAAGiJ,WAAWjG,EAAOC,GARnB,SAACzB,GAAD,OAAcA,EAAElD,EAAI0E,EAAQxB,EAAE9I,EAQDwQ,CAAQ1H,EAAEnF,IAAI2D,SAAMnK,KAC3D6D,QAAO,SAAAhB,GAAC,YAAU7C,IAAN6C,KAAkBkJ,MAAK,SAAC9I,EAAGU,GAAJ,OAAUV,EAAIU,KAEnD,MAAO,CACHoH,MAAO7H,EACPuB,MAAO7B,EAAI+I,EAAElD,GAAGkD,EAAE9I,GAClByQ,SAAUpQ,IAAMnB,EAAS,EAAI,GAAKoR,EAClCI,iBAAwB,IAANrQ,EAAU,EAAIkG,OAAOoK,qBAI3CC,EAAY,EACVC,EAAc,IAAI9P,IAAY,CAlBjB,IAmBZ8P,EAAYjN,KAAO,GAAG,CACzB1G,KAAKuK,eAAehC,KAAKmB,IAAIgK,IAActG,EAAO,MAClD,IAAMwG,GAAe,OAAID,EAAY/Q,UAAUC,KAAI,SAAAC,GAAC,OAAIoQ,EAAMpQ,MAC9D6Q,EAAYE,QAHa,gBAKND,GALM,IAKzB,2BAAiC,CAAC,IAAD,EAAtBxI,EAAsB,kBACPA,EAAKmI,UADE,IAC7B,2BAAqC,CAAC,IAA3BD,EAA0B,QAC3BjI,EAAK6H,EAAMI,GACXQ,EAAW1I,EAAKoI,iBAAmBnI,EAAG3G,MACxCoP,EAAWzI,EAAGmI,mBACdnI,EAAGmI,iBAAmBM,EACtBH,EAAYlN,IAAI4E,EAAGL,OACnBK,EAAGkI,SAASnP,SAAQ,SAAAtB,GAAC,OAAI6Q,EAAYlN,IAAI3D,QAPpB,gCALR,+BAkB7B,OAAOoQ,EAAMD,GAAUO,mBA1D/B,yBA6DI,SAAoBO,EAAgBC,GAIhC,IAHA,IAAMnR,EAAkBiD,MAAMiO,EAAS1G,OAAS2G,GAAOjO,KAAK,GAAGlD,KAAI,kBAAMiD,MAAMiO,EAAS3G,MAAQ4G,GAAOjO,KAAK,MACtGqH,EAAQvK,EAAI,GAAGb,OACfqL,EAASxK,EAAIb,OACV0G,EAAI,EAAGA,EAAI2E,EAAQ3E,IACxB,IAAK,IAAI5F,EAAI,EAAGA,EAAIsK,EAAOtK,IAAK,CAC5B,IAAMmR,EAAS1L,KAAK6F,MAAM1F,EAAIqL,EAAS1G,QAAU9E,KAAK6F,MAAMtL,EAAIiR,EAAS3G,OACzEvK,EAAI6F,GAAG5F,IAAMiR,EAASlR,IAAI6F,EAAIqL,EAAS1G,QAAQvK,EAAIiR,EAAS3G,OAAS6G,EAAS,GAAK,EAAI,EAI/F,MAAO,CAAEpR,IAAAA,EAAKuK,MAAAA,EAAOC,OAAAA,KAxE7B,uBA2EI,WACI,IAAMxK,EAAMQ,EAAa,OAAQrD,KAAKG,OAAO0C,KAAI,kCACxCf,MAAM,IAAIe,KAAI,SAAAC,GAAC,OAAIC,SAASD,SAGrC,MAAO,CAAED,IAAAA,EAAKuK,MAAOvK,EAAI,GAAGb,OAAQqL,OAAQxK,EAAIb,YAhFxD,GAA2BrC,I,QKbrBqO,ICIL3L,EAAa,CACVE,IAAK,GACLC,MAAO,kBAEX,4IAEI,WAEI,OADwBxC,KAAKmE,aAArB+P,YACWjR,QAAO,SAACC,EAAGJ,GAAJ,OAAUI,EAAIJ,EAAEqR,UAAS,KAJ3D,mBAOI,WACI,IAAQC,EAAepU,KAAKmE,aAApBiQ,WACR,OAAOpU,KAAKqU,SAASD,KAT7B,sBAYI,SAAiBE,GAAyB,IAAD,OACrC,GAAoB,YAAhBA,EAAOjV,KACP,OAAOiV,EAAO5P,MAGlB,IAAM6P,EAAUD,EAAOC,QACvB,OAAQD,EAAOE,UACX,KAAK,EAAG,OAAOD,EAAQtR,QAAO,SAACC,EAAGJ,GAAJ,OAAUI,EAAI,EAAKmR,SAASvR,KAAI,GAC9D,KAAK,EAAG,OAAOyR,EAAQtR,QAAO,SAACC,EAAGJ,GAAJ,OAAUI,EAAI,EAAKmR,SAASvR,KAAI,GAC9D,KAAK,EAAG,OAAOyR,EAAQ1R,KAAI,SAAAC,GAAC,OAAI,EAAKuR,SAASvR,MAAIG,QAAO,SAACC,EAAGJ,GAAJ,OAAUA,EAAII,EAAIJ,EAAII,KAC/E,KAAK,EAAG,OAAOqR,EAAQ1R,KAAI,SAAAC,GAAC,OAAI,EAAKuR,SAASvR,MAAIG,QAAO,SAACC,EAAGJ,GAAJ,OAAUA,EAAII,EAAIJ,EAAII,KAC/E,KAAK,EAAG,OAAOlD,KAAKqU,SAASE,EAAQ,IAAMvU,KAAKqU,SAASE,EAAQ,IAAM,EAAI,EAC3E,KAAK,EAAG,OAAOvU,KAAKqU,SAASE,EAAQ,IAAMvU,KAAKqU,SAASE,EAAQ,IAAM,EAAI,EAC3E,KAAK,EAAG,OAAOvU,KAAKqU,SAASE,EAAQ,MAAQvU,KAAKqU,SAASE,EAAQ,IAAM,EAAI,EAC7E,QAAS,MAAM,IAAI5S,MAAJ,4BAA+B2S,EAAOE,cA1BjE,wBA8BI,WAAsB,IAAD,IAEXC,GADG,oBAAG,YAAY/Q,KAAK1D,KAAKG,cAAzB,aAAG,EAA+B,UAAlC,QAAwC,IAC9B2B,MAAM,IAAIe,KAAI,SAAAC,GAAC,OAAIC,SAASD,EAAG,IAAI4R,SAAS,GAAGC,SAAS,EAAG,QAAM1P,KAAK,IACnFiP,EAAwB,GAC9B,MAAO,CAAEE,WAAYpU,KAAK4U,YAAYH,EAAQP,GAAaI,OAAQJ,YAAAA,KAlC3E,yBAqCI,SAAoBO,EAAgBP,GAChC,IAII3P,EAJEsQ,GAAa,QAAG,0CAAH,oBACbC,GAAkB,QAAG,2CAAH,iCAClBC,GAAiB,QAAG,2CAAH,gCAGvB,GAAKxQ,EAAQsQ,EAAcnR,KAAK+Q,GAC5B,OAAOzU,KAAKgV,mBAAmBzQ,EAAO2P,GACnC,GAAK3P,EAAQuQ,EAAmBpR,KAAK+Q,GACxC,OAAOzU,KAAKiV,oBAAoBR,EAAQlQ,EAAO2P,GAC5C,GAAK3P,EAAQwQ,EAAkBrR,KAAK+Q,GACvC,OAAOzU,KAAKiV,oBAAoBR,EAAQlQ,EAAO2P,GAGnD,MAAM,IAAIvS,MAAJ,iCAAoC8S,MAnDlD,gCAsDI,SAA2BlQ,EAAwB2P,GAC/C,MAA0B3P,EAAM2Q,OAAxBf,EAAR,EAAQA,QAASgB,EAAjB,EAAiBA,KACXb,EAAwB,CAC1BjV,KAAM,UACN8U,QAASpR,SAASoR,EAAS,GAC3BzP,MAAO3B,SAASM,EAAa,SAAU8R,GAAMtS,KAAI,SAAAC,GAAC,OAAIA,EAAE,GAAGE,MAAM,MAAIiC,KAAK,IAAK,IAInF,OAFAiP,EAAYxR,KAAK4R,GAEV,CAAEA,OAAAA,EAAQtS,OAAQuC,EAAM,GAAGvC,UA/D1C,iCAkEI,SAA4ByS,EAAgBlQ,EAAwB2P,GAAwB,IAAD,OACvF,EAA6C3P,EAAM2Q,OAA3Cf,EAAR,EAAQA,QAASK,EAAjB,EAAiBA,SAAUxS,EAA3B,EAA2BA,OAAQ+G,EAAnC,EAAmCA,MAC7BqM,EAAe7Q,EAAM,GAAGvC,OACxBsS,EAAyB,CAC3BjV,KAAM,WACN8U,QAASpR,SAASoR,EAAS,GAC3BK,SAAUzR,SAASyR,EAAU,GAC7BD,QAAS,IAEbL,EAAYxR,KAAK4R,GAEjB,IAAMe,EAAmB,SAACjK,GACtB,MAAqD,EAAKwJ,YAAYH,EAAOzR,MAAMoI,GAAO8I,GAA1EoB,EAAhB,EAAQhB,OAA6BiB,EAArC,EAA6BvT,OAE7B,OADAsS,EAAOC,QAAQ7R,KAAK4S,GACbC,GAGPC,EAAeJ,EACnB,QAAenV,IAAX+B,EAEA,IADA,IAAMyT,EAAmB1S,SAASf,EAAQ,GACnCwT,EAAeJ,EAAeK,GAAoBD,GAAgBH,EAAiBG,QAG1F,IADA,IAAME,EAAc3S,SAASgG,EAAO,GAC3B5F,EAAI,EAAGA,EAAIuS,EAAavS,IAAOqS,GAAgBH,EAAiBG,GAG7E,MAAO,CAAElB,OAAAA,EAAQtS,OAAQwT,OA5FjC,GAA2B7V,ICN1B0C,EAAa,CACVE,IAAK,GACLC,MAAO,cAEX,4IAEI,WACI,MAAiCxC,KAAKmE,aAA9BwR,EAAR,EAAQA,QAASC,EAAjB,EAAiBA,YAGjB,OAFiB5V,KAAK6V,WAAWF,EAASC,GAAlCpG,OAJhB,mBASI,WAMI,IALA,MAAiCxP,KAAKmE,aAA9ByR,EAAR,EAAQA,YAAaD,EAArB,EAAqBA,QACbG,EAAU9V,KAAK6V,WAAWF,EAASC,GAAnCE,MAGJC,EAAW,EACNC,EAHKJ,EAAYlN,EAGLsN,GAAMF,EAAOE,IAC9B,IAAK,IAAIC,EAAK,EAAGA,GAAML,EAAY9S,EAAGmT,IAC9BjW,KAAKkW,MAAMD,EAAID,EAAIL,EAASC,IAC5BG,IAKZ,OAAOA,IAvBf,mBA0BI,SAAcE,EAAYD,EAAYG,EAAWC,GAG7C,IAFA,IAAItT,EAAI,EACJ4F,EAAI,IACEsN,EAAK,GAAKtN,EAAI0N,EAAG1N,GAAM5F,EAAIsT,EAAGtT,GAAa,IAAPmT,GAAYnT,EAAIqT,EAAGrT,IAAK,CAGlE,GADA4F,GAAKsN,GADLlT,GAAKmT,IAEIE,EAAGrT,GAAKA,GAAKsT,EAAGtT,GAAK4F,GAAK0N,EAAG1N,GAAKA,GAAKyN,EAAGzN,EAC/C,OAAO,EAEXuN,EAAK1N,KAAKsB,IAAI,EAAGoM,EAAK,GACtBD,GAAU,EAGd,OAAO,IAvCf,wBA0CI,SAAmBG,EAAWC,GAK1B,IAJA,IAAIN,GAAS,EACTO,GAAc,EACdC,OAAmBrW,EACnBuP,EAAOnG,OAAO2F,iBACXqH,GAAa,CAChBP,IACA,IAAMS,EAAavW,KAAKwW,UAAUV,EAAOK,EAAIC,GACzCG,EAAWE,MAAOjH,EAAOjH,KAAKsB,IAAI2F,EAAM+G,EAAW/G,OACvD6G,EAAcE,EAAWE,MAAQH,MAAWA,EAAKG,KAC7CH,EAAKI,SAAWH,EAAWG,SAC3BJ,EAAKK,YAAcJ,EAAWI,YAClCL,EAAOC,EAGX,MAAO,CAAET,MAAAA,EAAOtG,KAAAA,KAzDxB,uBA4DI,SAAkBsG,EAAeK,EAAWC,GAOxC,IANA,IAAI1N,EAAI,EACJsN,EAAKF,EACLW,GAAM,EACNC,EAAU,EACVC,EAAa,EACbnH,EAAOnG,OAAO2F,mBACRgH,EAAK,GAAKtN,EAAI0N,EAAG1N,IAAK,CAG5B,GAFAA,GAAKsN,EACLxG,EAAOjH,KAAKsB,IAAI2F,EAAM9G,GAClBA,GAAK0N,EAAG1N,GAAKA,GAAKyN,EAAGzN,EAAG,CACxB+N,GAAM,EACN,MAEA/N,EAAIyN,EAAGzN,IAAKgO,EAAUhO,GAC1BsN,GAAU,EAId,OAFItN,EAAI0N,EAAG1N,IAAKiO,EAAajO,GAEtB,CAAE+N,IAAAA,EAAKC,QAAAA,EAASC,WAAAA,EAAYnH,KAAAA,KA/E3C,wBAkFI,WAAsB,IAAD,EACjB,GAAyB,UAACxP,KAAKG,MAC1BoE,MAAM,kEADc,QACgD,IACpEvB,MAAM,GAAGH,KAAI,SAAAC,GAAC,OAAIC,SAASD,MAFhC,eAAOmF,EAAP,KAAWE,EAAX,KAAeD,EAAf,KAIA,MAAO,CAAEyN,QAAS,CAAE7S,EAAGmF,EAAIS,EAJ3B,MAIoCkN,YAAa,CAAE9S,EAAGqF,EAAIO,EAAGR,QAvFrE,GAA2BvI,ICS1B0C,EAAa,CACVE,IAAK,GACLC,MAAO,aAEX,4IAEI,WAA2B,IAAD,OAEhBoU,EADU5W,KAAKmE,aACDlB,QAAO,SAACC,EAAGJ,GAAJ,OAAU,EAAK2D,IAAIvD,EAAGJ,MAGjD,OAFkB9C,KAAK6W,UAAUD,KALzC,mBAUI,WAGI,IAFA,IAAIE,EAAezN,OAAO2F,iBACpBtJ,EAAU1F,KAAKmE,aACZhB,EAAI,EAAGA,EAAInD,KAAK6B,WAAWG,OAAQmB,IAAK,CAC7CnD,KAAKuK,eAAepH,EAAInD,KAAK6B,WAAWG,QACxC,IAAK,IAAI+U,EAAI,EAAGA,EAAI/W,KAAK6B,WAAWG,OAAQ+U,IACxC,GAAI5T,IAAM4T,EAAV,CACA,IAAM7T,EAAIlD,KAAKgX,MAAMtR,EAAQvC,IACvBS,EAAI5D,KAAKgX,MAAMtR,EAAQqR,IACvBF,EAAY7W,KAAK6W,UAAU7W,KAAKyG,IAAIvD,EAAGU,IAC7CkT,EAAevO,KAAKsB,IAAIiN,EAAcD,IAI9C,OAAOC,IAxBf,uBA2BI,SAAkBG,GACd,MAAgB,UAAZA,EAAG5X,KAA2B4X,EAAGvS,MACA,EAA9B1E,KAAK6W,UAAUI,EAAGC,MAAM,IAAwC,EAA9BlX,KAAK6W,UAAUI,EAAGC,MAAM,MA7BzE,iBAgCI,SAAYC,EAAkBC,GAC1B,IAAM7X,EAAqBS,KAAKqX,iBAAiB,CAACF,EAAKC,IACvD7X,EAAO2X,MAAM9S,SAAQ,SAAC6S,EAAI9T,GACtB8T,EAAGK,OAAS/X,EACZ0X,EAAGM,aAAepU,KAItB,IADA,IAAIqU,GAAiB,EACdA,IACHA,EAAiBxX,KAAKyX,gBAAgBlY,MAEtCiY,EAAiBxX,KAAK0X,cAAcnY,IAGxC,OAAOA,IA9Cf,2BAiDI,SAAsB0X,GAA2B,IAAD,OAC5C,MAAgB,UAAZA,EAAG5X,KACC4X,EAAGvS,OAAS,KACZ1E,KAAK8B,MAAMmV,IACJ,GAKRA,EAAGC,MAAMS,MAAK,SAAAC,GAAK,OAAI,EAAKF,cAAcE,QA1DzD,6BA6DI,SAAwBX,GAAsC,IAAD,OAApBY,EAAoB,uDAAZ,EAC7C,MAAgB,UAAZZ,EAAG5X,OAEO,IAAVwY,GACA7X,KAAK8X,QAAQb,IACN,GAGJA,EAAGC,MAAMS,MAAK,SAAAC,GAAK,OAAI,EAAKH,gBAAgBG,EAAOC,EAAQ,SArE1E,qBAwEI,SAAgBZ,GAAuB,IAAD,YACf,CAAC,EAAG,IADW,IAClC,2BAAoC,CAAC,IAA1Bc,EAAyB,QAC1BC,EAAUhY,KAAKiY,iBAAiBhB,EAAGC,MAAMa,GAAqBA,GAChEC,IAAWA,EAAQtT,OAAUuS,EAAGC,MAAMa,GAAqBrT,QAHjC,8BAMlC,IAAKuS,EAAGK,OAAU,MAAM,IAAI3V,MAAM,iCAClCsV,EAAGK,OAAOJ,MAAMD,EAAGM,cAAiBvX,KAAKkY,iBAAiB,EAAGjB,EAAGK,OAAQL,EAAGM,gBA/EnF,mBAkFI,SAAcY,GAAuB,IAAD,OAC1BC,EAAKD,EACXC,EAAG/Y,KAAO,QACV+Y,EAAGlB,MAAQ,CAAC3O,KAAK6F,MAAM+J,EAAGzT,MAAQ,GAAI6D,KAAK8P,KAAKF,EAAGzT,MAAQ,IACtD7B,KAAI,SAAC6B,EAAO6S,GAAR,OAAyB,EAAKW,iBAAiBxT,EAAO0T,EAAIb,QAtF3E,8BAyFI,SAAyBY,EAAgBJ,GAIrC,IAFA,IAAId,EAAkBkB,EAClBH,OAAmC/X,GAC/B+X,GAAS,CACb,IAAKf,EAAGK,OAAU,OAAO,KACrBL,EAAGM,eAAiBQ,EACpBC,EAAUf,EAAGK,OAAOJ,MAAMa,GAE1Bd,EAAKA,EAAGK,OAMhB,IADA,IAAMgB,EAAuB,IAATP,EAAa,EAAI,EACb,UAAjBC,EAAQ3Y,MACX2Y,EAAUA,EAAQd,MAAMoB,GAG5B,OAAON,IA5Gf,wBA+GI,WAAqC,IAAD,OAChC,OAAOhY,KAAK6B,WAAWgB,KAAI,SAAAZ,GAAI,OAAI,EAAKsW,iBAAiBtW,QAhHjE,8BAmHI,SAAyBsB,GACrB,IACIiV,EAF4C,EAC1CnK,EAAsB,GAExB4D,EAAmBjS,KAAKqX,iBAAiB,IAHG,UAI7B9T,GAJ6B,IAIhD,2BAAyB,CAAC,IAAfgP,EAAc,QACrB,OAAQA,GACJ,IAAK,IACDiG,EAAWvG,EACX5D,EAAM3L,KAAK8V,GACXvG,EAAOjS,KAAKqX,iBAAiB,GAAImB,EAAUA,EAAStB,MAAMlV,QAC1DwW,EAAStB,MAAMxU,KAAKuP,GACpB,MACJ,IAAK,IAAKA,EAAO5D,EAAMG,MAAQ,MAC/B,IAAK,IAAK,MACV,QAASyD,EAAKiF,MAAMxU,KAAK1C,KAAKkY,iBAAiBnV,SAASwP,GAAON,EAAMA,EAAKiF,MAAMlV,WAdxC,8BAmBhD,OADAiQ,EAAKiF,MAAM,GAAGI,YAASrX,EAChBgS,EAAKiF,MAAM,KAtI1B,mBAyII,SAAcD,EAAiBK,GAAmC,IAAD,SAE7D,GADM,QAAN,EAAAA,SAAA,QAAAA,EAAWL,EAAGK,QACE,UAAZL,EAAG5X,KACH,OAAOW,KAAKkY,iBAAiBjB,EAAGvS,MAAO4S,EAASL,EAAGM,cAGvD,IAAMkB,EAAczY,KAAKqX,iBAAiB,GAAIC,EAAQL,EAAGM,cAGzD,OAFAN,EAAGC,MAAM9S,SAAQ,SAAAtB,GAAC,OAAI2V,EAAYvB,MAAMxU,KAAK,EAAKsU,MAAMlU,EAAG2V,OAEpDA,IAlJf,8BAqJI,SAAyBvB,EAAsBI,EAAqBC,GAChE,MAAmB,CAAElY,KAAM,QAAS6X,MAAAA,EAAOI,OAAAA,EAAQC,aAAAA,KAtJ3D,8BAyJI,SAAyB7S,EAAe4S,EAAoBC,GACxD,MAAmB,CAAElY,KAAM,QAASqF,MAAAA,EAAO4S,OAAAA,EAAQC,aAAAA,OA1J3D,GAA2B5X,IHnBrBqO,WACF,WAAmBlL,EAAkB4F,EAAkBgQ,IAAY,oBAAhD5V,EAAAA,EAA+C,KAA7B4F,EAAAA,EAA6B,KAAXgQ,EAAAA,EAatD,OAboE,2BAErE,SAAI9M,GAAmB,OAAO,IAAIoC,EAAMhO,KAAK8C,EAAI8I,EAAE9I,EAAG9C,KAAK0I,EAAIkD,EAAElD,EAAG1I,KAAK0Y,EAAI9M,EAAE8M,KAAK,iBACpF,SAAI9M,GAAmB,OAAO,IAAIoC,EAAMhO,KAAK8C,EAAI8I,EAAE9I,EAAG9C,KAAK0I,EAAIkD,EAAElD,EAAG1I,KAAK0Y,EAAI9M,EAAE8M,KAAK,uBACpF,SAAU9M,GAAoB,OAAOrD,KAAKkB,IAAIzJ,KAAK8C,EAAI8I,EAAE9I,GAAKyF,KAAKkB,IAAIzJ,KAAK0I,EAAIkD,EAAElD,GAAKH,KAAKkB,IAAIzJ,KAAK0Y,EAAI9M,EAAE8M,KAAK,mBAChH,SAAM9M,GAAqB,OAAO5L,KAAK8C,IAAM8I,EAAE9I,GAAK9C,KAAK0I,IAAMkD,EAAElD,GAAK1I,KAAK0Y,IAAM9M,EAAE8M,IAAI,sBAEvF,WAAqB,MAAM,GAAN,OAAU1Y,KAAK8C,EAAf,YAAoB9C,KAAK0I,EAAzB,YAA8B1I,KAAK0Y,KAAM,oBAE9D,WAAmB,MAAO,CAAC,CAAC1Y,KAAK8C,GAAI,CAAC9C,KAAK0I,GAAI,CAAC1I,KAAK0Y,OAAM,mBAC3D,SAAYC,GACR,cAAwBA,EAAxB,GACA,OAAO,IAAI3K,GADX,6DAEH,EAdCA,IAoBA4K,GAAS,IAAI5K,GAAM,EAAG,EAAG,G,IAG9B3L,EAAa,CACVE,IAAK,GACLC,MAAO,kBAEX,mMAEIqW,UAAsB,EAAKC,yBAF/B,EAGIC,iBAA8B,GAHlC,sCAKI,WAcI,IAduB,IAAD,OAChBC,EAAWhZ,KAAKmE,aAChB8U,EAAQjZ,KAAKkZ,eAAeF,GAC7BnW,KAAI,WAASmI,EAAOmO,GAAS,IAAD,eAAtBjW,EAAsB,KAAnBU,EAAmB,KAEzB,OADA,EAAK2G,eAAeS,EAAQmO,EAAInX,QACzB,CAAEkB,EAAAA,EAAGU,EAAAA,EAAGwV,QAAS,EAAKA,QAAQlW,EAAGU,OAE3CE,QAAO,SAAA8H,GAAC,OAAIA,EAAEwN,WACdrH,SAAQ,SAAAnG,GAAC,MAAI,CAACA,EAAG,CACd1I,EAAG0I,EAAEhI,EAAGA,EAAGgI,EAAE1I,EACbkW,QAAS,CAAEC,QAASzN,EAAEwN,QAAQE,QAASA,QAAS1N,EAAEwN,QAAQC,cAG5DE,EAAW,IAAI1V,IAAY,CAAC,IAC3B0V,EAAS7S,KAAOsS,EAAShX,QAAQ,CACpC,IAAMwX,EAAYP,EAAMQ,WAAU,SAAA7N,GAAC,OAAI2N,EAASxV,IAAI6H,EAAE1I,EAAEwW,MAAQH,EAASxV,IAAI6H,EAAEhI,EAAE8V,OACjF,EAA0BT,EAAMO,GAAxBtW,EAAR,EAAQA,EAAGU,EAAX,EAAWA,EAAGwV,EAAd,EAAcA,QACdpZ,KAAK2Z,SAASzW,EAAGU,EAAGwV,GACpBG,EAAS9S,IAAI7C,EAAE8V,IACfT,EAAM9W,OAAOqX,EAAW,GAE5BxZ,KAAK+Y,iBAAmBC,EAExB,IAAMY,EAAW,IAAI/V,IAGrB,OAFAmV,EAAS5U,SAAQ,SAAAyV,GAAC,OAAIA,EAAE9I,OAAO3M,SAAQ,SAAAwH,GAAC,OAAIgO,EAASnT,IAAImF,EAAE8I,kBAEpDkF,EAASlT,OA/BxB,mBAkCI,WAKI,OAJoB1G,KAAKkZ,eAAelZ,KAAK+Y,kBACxC9V,QAAO,SAAC4G,EAAD,sBAAO3G,EAAP,KAAUU,EAAV,YAAiB2E,KAAKsB,IAAIA,EAAK3G,EAAE+Q,OAAO6F,UAAUlW,EAAEqQ,WACxD5K,OAAO2F,oBArCvB,sBA2CI,SAAiB+K,EAAaC,EAAaZ,GAA4B,IAAD,SAC1DC,EAAqBD,EAArBC,QAASC,EAAYF,EAAZE,QACXW,EAAKF,EAAGhJ,OAAOsI,GAF6C,UAG3CrZ,KAAK6Y,WAHsC,yBAGvDqB,EAHuD,QAIxDC,EAAgBH,EAAGjJ,OAAOlO,KAAI,SAAA+I,GAAC,OAAIoC,GAAM5C,KAAK,EAAKgP,SAASF,EAAUtO,EAAE+M,cACxE1E,EAASgG,EAAGjW,IAAImW,EAAcb,IAC9Be,EAAeF,EAActX,KAAI,SAAA+I,GAAC,OAAIA,EAAEnF,IAAIwN,MAGlD,GADqBoG,EAAapX,QAAO,SAACC,EAAG0I,GAAJ,OAAU1I,GAAK6W,EAAGhJ,OAAO4G,MAAK,SAAA2C,GAAG,OAAIA,EAAIC,MAAM3O,MAAM,EAAI,KAAI,IAzDzF,GA6DT,OAFAoO,EAAGjJ,OAASsJ,EACZL,EAAG/F,OAASA,EACN,CAAN,GAAO,IATf,2BAAuC,CAAC,IAAD,yCAH2B,8BAgBlE,OAAO,IA3Df,4BA+DI,SAA0BiD,GAGtB,IAFA,IAAMlV,EAASkV,EAAMlV,OACfiX,EAAkB,GACf9V,EAAI,EAAGA,EAAInB,EAAQmB,IAExB,IADA,IAAMD,EAAIgU,EAAM/T,GACP4T,EAAI5T,EAAI,EAAG4T,EAAI/U,EAAQ+U,IAC5BkC,EAAMvW,KAAK,CAACQ,EAAGgU,EAAMH,KAI7B,OAAOkC,IAzEf,qBAgFI,SAAgBc,EAAaC,GACzB,IAAK,IAAI7W,EAAI,EAAGA,EAAI4W,EAAGS,kBAAkBxY,OAAQmB,IAE7C,IADA,IAAMsX,EAAKV,EAAGS,kBAAkBrX,GACvB4T,EAAI,EAAGA,EAAIiD,EAAGQ,kBAAkBxY,OAAQ+U,IAAK,CAClD,IAAM2D,EAAKV,EAAGQ,kBAAkBzD,GAC1BqC,EAAUpZ,KAAK2a,gBAAgBF,EAAIC,GACzC,GAAItB,EAAQpX,QAAU4Y,GAClB,MAAO,CAAEvB,QAASlW,EAAGmW,QAASvC,GAK1C,OAAO,IA5Ff,6BAgGI,SAAwB7T,EAAaU,GACjC,IADwD,EAClDrE,EAAmB,GACrBsb,EAAS,EAF2C,UAGrC3X,GAHqC,IAGxD,2BAAsB,CAClB,IADmB,IAAZ4X,EAAW,QACXlX,EAAEiX,GAAUC,GAAQD,IACvBjX,EAAEiX,KAAYC,IACdvb,EAAOmD,KAAKoY,GACZD,MAPgD,8BAWxD,OAAOtb,IA3Gf,wBA8GI,WAWI,OAVuB8D,EAAa,uDAAwDrD,KAAKG,OACjE0C,KAAI,YAA+B,IAAD,eAA1BkY,EAA0B,KAAjBC,EAAiB,KACxDtB,EAAK3W,SAASgY,GACdhK,EAAS1N,EAAa,2BAA4B2X,GACnDnY,KAAI,SAAAyO,GAAC,OAAIA,EAAEtO,MAAM,GAAGH,KAAI,SAAAC,GAAC,OAAIC,SAASD,SACtCD,KAAI,+BAAEC,EAAF,KAAK4F,EAAL,KAAQgQ,EAAR,YAAe,IAAI1K,GAAMlL,EAAG4F,EAAGgQ,MAClC8B,EAAoBzJ,EAAOlO,KAAI,SAAAoX,GAAE,OAAIlJ,EAAOlO,KAAI,SAAAoY,GAAE,OAAIhB,EAAGH,UAAUmB,MAAKjP,MAAK,SAAC9I,EAAGU,GAAJ,OAAUV,EAAIU,KAAGZ,MAAM,MAC1G,MAAO,CAAE0W,GAAAA,EAAI3I,OAAAA,EAAQyJ,kBAAAA,EAAmBvG,OAAQ2E,SAtH5D,oCA+HI,WAA4C,IAAD,OAEjCsC,EAAoC,CAAC,EAAG,GAAI,IAAK,KAAKrY,KAAI,SAAAuH,GAAC,OAAcA,Gf3HnE7B,KAAK4S,GAAK,Qe4HhBC,EAAMF,EAAerY,KAAI,SAAAK,GAAC,OAAI,EAAKmY,GAAGnY,MACtCoY,EAAMJ,EAAerY,KAAI,SAAAK,GAAC,OAAI,EAAKqY,GAAGrY,MACtCsY,EAAMN,EAAerY,KAAI,SAAAK,GAAC,OAAI,EAAKuY,GAAGvY,MAGtCiO,EAAa,IAAItN,IAOvB,OANkBuX,EACbrJ,SAAQ,SAAA2J,GAAE,OAAIJ,EAAIzY,KAAI,SAAA8Y,GAAE,MAAI,CAACD,EAAIC,SACjC5J,SAAQ,+BAAE2J,EAAF,KAAMC,EAAN,YAAcH,EAAI3Y,KAAI,SAAA+Y,GAAE,MAAI,CAACF,EAAIC,EAAIC,SAC7C/Y,KAAI,SAAAgZ,GAAC,OAAIA,EAAE5Y,QAAO,SAACC,EAAGJ,GAAJ,OAAU,EAAKsX,SAASlX,EAAGJ,SAC7CgB,QAAO,SAAA+X,GAAC,OAAK1K,EAAWpN,IAAI8X,EAAE5W,KAAK,OAASkM,EAAW1K,IAAIoV,EAAE5W,KAAK,WA5I/E,sBAkJI,SAAiB6W,EAAYC,GAIzB,IAHA,IAAM1O,EAASyO,EAAG9Z,OACZoL,EAAQ2O,EAAG,GAAG/Z,OACdzC,EAAiBuG,MAAMuH,GAAQtH,KAAK,GAAGlD,KAAI,kBAAMiD,MAAMsH,MACpDvG,EAAM,EAAGA,EAAMwG,EAAQxG,IAC5B,IADoC,IAAD,WAC1BG,GACLzH,EAAOsH,GAAKG,GAAO8U,EAAGjV,GAAKhE,KAAI,SAACoF,EAAI+T,GAAL,OAAY/T,EAAK8T,EAAGC,GAAIhV,MAAM/D,QAAO,SAACC,EAAGJ,GAAJ,OAAUI,EAAIJ,MAD7EkE,EAAM,EAAGA,EAAMoG,EAAOpG,IAAQ,EAA9BA,GAKb,OAAOzH,IA5Jf,gBAgKI,SAAW2K,GAAqB,OAAOlK,KAAKic,UAAU,CAAC,CAAC,EAAG,EAAG,GAAI,CAAC,EAAG1T,KAAK2T,IAAIhS,IAAK3B,KAAK4T,IAAIjS,IAAK,CAAC,EAAG3B,KAAK4T,IAAIjS,GAAI3B,KAAK2T,IAAIhS,QAhKhI,gBAiKI,SAAWA,GAAqB,OAAOlK,KAAKic,UAAU,CAAC,CAAC1T,KAAK2T,IAAIhS,GAAI,EAAG3B,KAAK4T,IAAIjS,IAAK,CAAC,EAAG,EAAG,GAAI,EAAE3B,KAAK4T,IAAIjS,GAAI,EAAG3B,KAAK2T,IAAIhS,QAjKhI,gBAkKI,SAAWA,GAAqB,OAAOlK,KAAKic,UAAU,CAAC,CAAC1T,KAAK2T,IAAIhS,IAAK3B,KAAK4T,IAAIjS,GAAI,GAAI,CAAC3B,KAAK4T,IAAIjS,GAAI3B,KAAK2T,IAAIhS,GAAI,GAAI,CAAC,EAAG,EAAG,OAlKjI,uBAqKI,SAAkBkS,GAAkB,OAAOA,EAAOvZ,KAAI,SAAAZ,GAAI,OAAIA,EAAKY,KAAI,SAAAC,GAAC,OAAIA,EAAI,EAAIyF,KAAK8P,KAAKvV,GAAKyF,KAAK6F,MAAMtL,aArKlH,GAA2BnD,II1B1B0C,EAAa,CACVE,IAAK,GACLC,MAAO,cAEX,mMAEI6Z,eAAgB,EAFpB,sCAII,WACI,MAA6Brc,KAAKmE,aAA1BkN,EAAR,EAAQA,MAAOiL,EAAf,EAAeA,UACT/c,EAASS,KAAKuc,QAAQlL,EAAOiL,EAAW,GAE9C,OAAOtc,KAAKwc,WAAWjd,GAAQkd,aARvC,mBAWI,WACI,MAA6Bzc,KAAKmE,aAA1BkN,EAAR,EAAQA,MAAOiL,EAAf,EAAeA,UACT/c,EAASS,KAAKuc,QAAQlL,EAAOiL,EAAW,IAE9C,OAAOtc,KAAKwc,WAAWjd,GAAQkd,aAfvC,qBAkBI,SAAgBpL,EAAciL,EAAmBvT,GAC7C/I,KAAKqc,eAAgB,EAGrB,IAFA,IAAMK,EAAsC,MAAjBJ,EAAU,GAE5BnZ,EAAI,EAAGA,EAAI4F,EAAO5F,IAAK,CAC5BnD,KAAKuK,eAAepH,EAAI4F,GAIxB,IAHA,MAAuC/I,KAAKwc,WAAWnL,GAA/ChC,EAAR,EAAQA,OAAQC,EAAhB,EAAgBA,OAAQqN,EAAxB,EAAwBA,KAAMC,EAA9B,EAA8BA,KACxBvb,EAAc,GAEXqH,EAAI4G,EAAS,EAAG5G,GAAKkU,EAAO,EAAGlU,IACpC,IAAK,IAAI5F,EAAIuM,EAAS,EAAGvM,GAAK6Z,EAAO,EAAG7Z,IAAK,CACzC,IAAM4B,EAAQ4X,EAAUtc,KAAK6c,eAAexL,EAAOvO,EAAG4F,IACtD1I,KAAK0H,IAAIrG,EAAMyB,EAAG4F,EAAGhE,GAI7B2M,EAAQhQ,EACRrB,KAAKqc,cAAgBK,IAAuB1c,KAAKqc,cAGrD,OAAOhL,IAtCf,4BAyCI,SAAuBA,EAAcvO,EAAW4F,GAE5C,IADA,IAAMoU,EAAuB,GACpB/F,EAAIrO,EAAI,EAAGqO,GAAKrO,EAAI,EAAGqO,IAC5B,IAAK,IAAI5T,EAAIL,EAAI,EAAGK,GAAKL,EAAI,EAAGK,IAC5B2Z,EAAWpa,KAAK1C,KAAKoG,IAAIiL,EAAOlO,EAAG4T,IAI3C,OAAOhU,SAAS+Z,EAAW7X,KAAK,IAAK,KAjD7C,wBAoDI,WAAsB,IAAD,SACX8X,EAAe,SACrB,YAAuC/c,KAAKG,MAAMoE,MAAM,2DAAxD,QAA+G,GAA/G,eAASyY,EAAT,KAAyBC,EAAzB,KACMX,EAAYU,EAAeE,QAAQH,EAAc,IAAIG,QAAQ,MAAO,KAAKA,QAAQ,KAAM,KACvF7L,EAAe,GAKrB,OAJA4L,EAAWnb,MAAMib,GACZ3Y,SAAQ,SAACnC,EAAMyG,GAAP,OAAazG,EAAKH,MAAM,IAC5BsC,SAAS,SAAC+Y,EAAGra,GAAJ,OAAU,EAAK4E,IAAI2J,EAAOvO,EAAG4F,EAAS,MAANyU,EAAY,IAAM,WAE7D,CAAEb,UAAAA,EAAWjL,MAAAA,KA7D5B,iBAgEI,SAAYA,EAAcvO,EAAW4F,EAAWhE,QAC3BzE,IAAboR,EAAM3I,KAAoB2I,EAAM3I,GAAK,IACzC2I,EAAM3I,GAAG5F,GAAK4B,IAlEtB,iBAqEI,SAAY2M,EAAcvO,EAAW4F,GACjC,IAAM7B,EAAMwK,EAAM3I,GAClB,YAAYzI,IAAR4G,QAAgC5G,IAAX4G,EAAI/D,GAA2B9C,KAAKqc,cAAgB,IAAM,IAC5ExV,EAAI/D,KAxEnB,wBA2EI,SAAmBuO,GACf,IAAKhC,EAA2C,EAAnCC,EAAsC,EAA9BqN,EAAiC,EAA3BC,EAA8B,EAAxBH,EAA2B,EAU5D,OATAvR,OAAOuB,QAAQ4E,GAAOjN,SAAQ,+BAAEsE,EAAF,KAAK7B,EAAL,YAAcqE,OAAOuB,QAAQ5F,GAAKhE,KAAI,YAAa,IAAD,eAAVC,EAAU,KAClE,MADkE,OAExEuM,EAAS9G,KAAKmB,IAAI2F,EAAQtM,SAASD,IACnCwM,EAAS/G,KAAKmB,IAAI4F,EAAQvM,SAAS2F,IACnCiU,EAAOpU,KAAKsB,IAAI8S,EAAM5Z,SAASD,IAC/B8Z,EAAOrU,KAAKsB,IAAI+S,EAAM7Z,SAAS2F,IAC/B+T,WAGD,CAAEpN,OAAAA,EAAQC,OAAAA,EAAQqN,KAAAA,EAAMC,KAAAA,EAAMH,WAAAA,KAtF7C,uBAyFI,SAAkBpL,GACd,MAAuCrR,KAAKwc,WAAWnL,GAA/ChC,EAAR,EAAQA,OAAQC,EAAhB,EAAgBA,OAAQqN,EAAxB,EAAwBA,KAAMC,EAA9B,EAA8BA,KAC9BlN,QAAQC,IAAI,CAAEN,OAAAA,EAAQC,OAAAA,EAAQqN,KAAAA,EAAMC,KAAAA,IACpC,IAAK,IAAIlU,EAAI4G,EAAQ5G,GAAKkU,EAAMlU,IAAK,CAEjC,IADA,IAAIzG,EAAO,GACFa,EAAIuM,EAAQvM,GAAK6Z,EAAM7Z,IAC5Bb,GAAkC,MAA1BjC,KAAKoG,IAAIiL,EAAOvO,EAAG4F,GAAa,IAAM,IAElDgH,QAAQC,IAAI1N,QAjGxB,GAA2BtC,ICF1B0C,EAAa,CACVE,IAAK,GACLC,MAAO,cAEX,4IAEI,WAQI,IAPA,IAAM4a,EAAUpd,KAAKmE,aAIjBkZ,EAAc,EACdC,EAAY,EACZC,EAAY,EACTH,EAAQC,GAAatM,OANN,KAM8B,CAEhD,IADA,IAAIyM,EAAa,EACRra,EAAI,EAAGA,EAlBP,EAkByBA,IAC9Bqa,IAAeF,IAAc,GARnB,IAQoC,EAC9CC,IAIJ,IAAME,EAASL,EADfC,GAAeA,EAAc,GAAK,GAElCI,EAAO1Y,KAAO0Y,EAAO1Y,IAAMyY,EAAa,GA1BlC,GA0BmD,EACzDC,EAAO1M,QAAU0M,EAAO1Y,IAG5B,OAAOqY,GAASC,EAAc,GAAK,GAAGtM,OAASwM,IAvBvD,mBA0BI,WACI,IAAMH,EAAUpd,KAAKmE,aACf6B,EAAOhG,KAAK0d,UAAU,EAAGN,EAAQ,GAAGrY,IAAKqY,EAAQ,GAAGrM,OAAQqM,EAAQ,GAAGrY,IAAKqY,EAAQ,GAAGrM,QAE7F,OAAOxI,KAAKsB,IAAI7D,EAAKiU,GAAIjU,EAAKiV,MA9BtC,uBAiCI,SAAkBwC,EAAgBE,EAAcC,EAAgBC,EAAcC,EAAgBC,GAAgF,IAAD,EACpK,QAAL,EAAAA,SAAA,QAAAA,EAAU,IAAIzW,KACd,IAAM0W,EAAOhe,KAAKge,KAAKP,EAAQE,EAAMC,EAAQC,EAAMC,GAC7C9X,EAAO,CAAEiU,GAAI,EAAGgB,GAAI,GAGtB2C,GAFiB,IAGjB5X,EAAKiU,GAAK,EAAG8D,EAAMrW,IAAIsW,EAAMhY,IACtB8X,GAJU,KAKjB9X,EAAKiV,GAAK,EAAG8C,EAAMrW,IAAIsW,EAAMhY,IAGjC,IAAMiY,EAASF,EAAM3X,IAAI4X,GACzB,GAAIC,EAAU,OAAOA,EAGrB,IADA,IACA,MADyB,CAAC,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,IAC9E,eAAmD,CAA9C,sBAAOC,EAAP,KAAaC,EAAb,KACD,GAAc,GAAVV,EAAa,CACb,IAAMW,GAAYT,EAAOO,EAAO,GA1D9B,GA0D+C,EAC3CG,EAAaT,EAASQ,EAC5B,EAAmBpe,KAAK0d,UAAU,EAAGU,EAAUC,EAAYR,EAAMC,EAAQC,GAAjE9D,EAAR,EAAQA,GAAIgB,EAAZ,EAAYA,GACZjV,EAAKiU,IAAMkE,EAAalE,EACxBjU,EAAKiV,IAAMkD,EAAalD,MACrB,CACH,IAAMqD,GAAYT,EAAOK,EAAO,GAhE9B,GAgE+C,EAC3CK,EAAaT,EAASQ,EAC5B,EAAmBte,KAAK0d,UAAU,EAAGC,EAAMC,EAAQU,EAAUC,EAAYR,GAAjE9D,EAAR,EAAQA,GAAIgB,EAAZ,EAAYA,GACZjV,EAAKiU,IAAMkE,EAAalE,EACxBjU,EAAKiV,IAAMkD,EAAalD,GAKhC,OADA8C,EAAMrW,IAAIsW,EAAMhY,GACTA,IAlEf,kBAqEI,SAAayX,EAAgBE,EAAcC,EAAgBC,EAAcC,GACrE,OAA+D,KAAd,KAAhB,KAAd,IAATL,EAAeE,GAAcC,GAAgBC,GAAcC,IAtE7E,wBAyEI,WACI,OAAOza,EAAa,wCAAyCrD,KAAKG,OAC7D0C,KAAI,SAAA0B,GAAK,MAAK,CACXmV,GAAI3W,SAASwB,EAAM,IACnBQ,IAAKhC,SAASwB,EAAM,IACpBwM,OAAQ,UA9ExB,GAA2BpR,I,SCIrB6e,ICELnc,EAAa,CACVE,IAAK,GACLC,MAAO,kBAEX,4IAEI,WACI,IAAQic,EAAcze,KAAKmE,aAAnBsa,UACR,OAAOze,KAAK0e,aAAaD,KAJjC,mBAOI,WACI,IAAQxN,EAAUjR,KAAKmE,aAAf8M,MACR,OAAOjR,KAAK0e,aAAazN,KATjC,0BAYI,SAAqBA,GAAwB,IAAD,OAClC0N,EAAyB,GAkB/B,OAjBA1N,EAAM7M,SAAQ,WAAkB4G,GAAW,IAA1B4T,EAAyB,EAAzBA,KAAMte,EAAmB,EAAnBA,MACnB,EAAKiK,eAAeS,EAAQiG,EAAMjP,QAElC,IAHsC,EAGhC6c,EAAgBF,EACjB9b,KAAI,SAAAic,GAAM,MAAK,CAAEA,OAAAA,EAAQC,KAAM,EAAKC,iBAAiBF,EAAQF,OAC7D9a,QAAO,SAAAhB,GAAC,OAAIA,EAAEic,QALmB,UAOPF,GAPO,IAOtC,2BAA8C,CAAC,IAAD,UAAjCC,EAAiC,EAAjCA,OAAQC,EAAyB,EAAzBA,KACjBA,EAAKze,OAAQ,EACbwe,EAAOG,MAAMvc,KAAKqc,IATgB,8BAYlCze,GACAqe,EAAQjc,KAAK,CAAEpC,MAAOA,EAAO4e,KAAMN,EAAMK,MAAO,QAIjDN,EAAQ1b,QAAO,SAACC,EAAGJ,GAAJ,OAAUI,EAAI,EAAKic,OAAOrc,KAAI,KA/B5D,8BAkCI,SAAyBI,EAAgBU,GAA+B,IAAD,OAC7Dsb,EAAOlf,KAAKof,UAAUlc,EAAEgc,KAAMtb,GACpC,QAAKsb,GAGE,CAAEA,KAAAA,EAAMD,MAFD/b,EAAE+b,MAAMpc,KAAI,SAAAwc,GAAC,OAAI,EAAKL,iBAAiBK,EAAGzb,MAAmBE,QAAO,SAAAhB,GAAC,OAAIA,KAEjExC,OAAQ4C,EAAE5C,SAvCxC,oBA0CI,SAAewe,GACX,IADwC,EACpCK,EAASL,EAAOI,KAAKC,OADe,UAErBL,EAAOG,OAFc,IAExC,2BAAiC,CAAC,IAAvBF,EAAsB,QAC7BI,GAAUnf,KAAKmf,OAAOJ,IAHc,8BAMxC,OAAOI,IAhDf,uBAmDI,SAAkBjc,EAASU,GACvB,IAAMqE,EAAKM,KAAKsB,IAAI3G,EAAE+E,GAAIrE,EAAEqE,IACtBE,EAAKI,KAAKmB,IAAIxG,EAAEiF,GAAIvE,EAAEuE,IACtBD,EAAKK,KAAKsB,IAAI3G,EAAEgF,GAAItE,EAAEsE,IACtBE,EAAKG,KAAKmB,IAAIxG,EAAEkF,GAAIxE,EAAEwE,IACtBkX,EAAK/W,KAAKsB,IAAI3G,EAAEoc,GAAI1b,EAAE0b,IACtBC,EAAKhX,KAAKmB,IAAIxG,EAAEqc,GAAI3b,EAAE2b,IAC5B,QAAItX,EAAKE,GAAMD,EAAKE,GAAMkX,EAAKC,IAExBvf,KAAKwf,WAAWvX,EAAIE,EAAID,EAAIE,EAAIkX,EAAIC,KA5DnD,wBA+DI,WAAsB,IAAD,OACXE,EAAQpc,EAAa,2EAA4ErD,KAAKG,OACvG0C,KAAI,YAAsC,IAAD,cAChCvC,EAAuB,OADS,KAEhCof,EAFgC,WAEV7c,KAAI,SAAAC,GAAC,OAAIC,SAASD,MACxC6c,EAAaD,EAAO/T,OAAM,SAAA7I,GAAC,OAAIA,IAAM,IAAMA,GAAK,MACtD,UAAiC4c,EAAjC,GAAOzX,EAAP,KAAWE,EAAX,KAAeD,EAAf,KAAmBE,EAAnB,KAAuBkX,EAAvB,KAA2BC,EAA3B,KAGA,MAAO,CAAEI,WAAAA,EAAYrf,MAAAA,EAAOse,KAFf,EAAKY,WAAWvX,EAAIE,EAAID,EAAIE,EAAIkX,EAAIC,GAEfN,MAAO,OAGjD,MAAO,CAAEhO,MAAOwO,EAAiBhB,UAAWgB,EAAM3b,QAAO,SAAAhB,GAAC,OAAIA,EAAE6c,iBA3ExE,wBA8EI,SAAmB1X,EAAYE,EAAYD,EAAYE,EAAYkX,EAAYC,GAC3E,MAAO,CAAEtX,GAAAA,EAAIE,GAAAA,EAAID,GAAAA,EAAIE,GAAAA,EAAIkX,GAAAA,EAAIC,GAAAA,EAAIJ,QAAShX,EAAKF,EAAK,IAAMG,EAAKF,EAAK,IAAMqX,EAAKD,EAAK,QA/E5F,GAA2B3f,IDNb,KAEd,WAAgC,CAAC,EAAG,EAAG,EAAG,GAA1C,GAAcigB,IAAd,aAA0BC,IAA1B,aACMC,GAAgC,CAAE,EAAK,EAAG,EAAK,GAAI,EAAK,IAAK,EAAK,KEblEjN,IFeLxQ,EAAa,CACVE,IAAK,GACLC,MAAO,YAEX,mMACY4K,MAAQ,EADpB,EAEYC,OAAS,EAFrB,EAGYwF,WAAuB,GAHnC,sCAKI,WACI,IAAMkN,EAAU/f,KAAKmE,WAAW,aAC1B6b,EAAahgB,KAAKigB,cAAcF,GAGtC,OAFiB/f,KAAKkgB,aAAaH,EAASC,KARpD,mBAaI,WACI,IAAMD,EAAU/f,KAAKmE,WAAW,mBAC1B6b,EAAahgB,KAAKigB,cAAcF,GAGtC,OAFiB/f,KAAKkgB,aAAaH,EAASC,KAhBpD,2BAqBI,SAAsBD,GAClB,IAAMI,EAAgBjV,OAAOC,YAAYD,OAAOkV,KAAKN,IAAOjd,KAAI,SAAAwd,GAAC,MAAI,CAACA,EAAG,OAMzE,OALmBrgB,KAAKge,KAAK+B,EAAQ9W,MAChCpG,KAAI,SAAA6I,GAAC,MAAK,CAAE4U,KAAM5U,EAAE4U,KAAMvb,IAAKgb,EAAQQ,QAAQ7U,EAAE4U,MAAMH,EAAczU,EAAE4U,aACvEtU,MAAK,SAAC9I,EAAGU,GAAJ,OAAUV,EAAEod,KAAKE,cAAc5c,EAAE0c,YAzBnD,0BA+BI,SAAqBP,EAAkBC,GAA2G,IAAD,OAAtF/P,EAAsF,uDAA5E,IAAI3I,IAAuBmZ,EAAiD,uDAA1C,EAAG/W,EAAuC,uDAAjCL,OAAOoK,iBACnH,GAAIgN,GAAQ/W,EAAO,OAAOA,EAE1B,IAAQ7G,EAAoDkd,EAApDld,IAAKoG,EAA+C8W,EAA/C9W,MAAOyX,EAAwCX,EAAxCW,QAASC,EAA+BZ,EAA/BY,WAAYJ,EAAmBR,EAAnBQ,QAASK,EAAUb,EAAVa,MAC5C5C,EAAOhe,KAAKge,KAAK/U,GACjB4X,EAAc5Q,EAAQ7J,IAAI4X,GAChC,QAAoB/d,IAAhB4gB,GAA6BA,GAAeJ,EAAQ,OAAO/W,EAE/D,GADAuG,EAAQvI,IAAIsW,EAAMyC,GACdzC,IAASgC,EAAc,OAAOS,EAElC,IAAMK,EAAmB,IAAIjd,IAAIoF,EAAMpG,KAAI,SAAAC,GAAC,OAAIA,EAAEiC,QAC5Cgc,EAAqB9X,EACtBpG,KAAI,SAACme,GACF,IAAQV,EAAcU,EAAdV,KAAMvb,EAAQic,EAARjc,IACVkc,EAA6B,GACjC,GAAIN,EAAW5c,IAAIgB,IAEf,GAAIwb,EAAQD,GAAM3U,OAAM,SAAAC,GAAC,OAAI/I,EAAI+I,KAAO4S,IAAS3b,EAAI+I,KAAO0U,KAAO,CAC/D,IAAM/W,EAASgX,EAAQD,GAAMxc,QAAO,SAAA8H,GAAC,OAAI/I,EAAI+I,KAAO4S,MAAO,QAC5Cve,IAAXsJ,IAAwB0X,EAAmB,CAAC1X,UAIhD1G,EAAIme,EAAKjc,IAAM,EAAK8N,WAAWgN,OAASrB,IAAU+B,EAAQS,EAAKV,MAAM3U,OAAM,SAAAC,GAAC,OAAI/I,EAAI+I,KAAOoV,EAAKV,UAChGW,EAAmBP,EAAQ5c,QAAO,SAAA8H,GAAC,OAAI/I,EAAI+I,KAAO4S,OAI1D,IAAM0C,EAAkBD,EACnBpe,KAAI,SAAAse,GAAS,OAAIP,EAAMI,EAAKjc,KAAKoc,MACjCrd,QAAO,SAAAsd,GAAI,OAAa,OAATA,GAAiBA,EAAKzV,OAAM,SAAAC,GAAC,OAAKkV,EAAiB/c,IAAI6H,SAE3E,MAAO,CAAEoV,KAAAA,EAAMJ,MAAOM,MAEzBpd,QAAO,SAAAhB,GAAC,OAAIA,GAAKA,EAAE8d,MAAM5e,OAAS,KAClC+P,SAAQ,gBAAGiP,EAAH,EAAGA,KAAH,SAASJ,MAAkB/d,KAAI,SAAAue,GAAI,MAAK,CAC7CJ,KAAAA,EAAMI,KAAAA,EAAMC,iBAAkB,EAAKvH,UAAUsH,EAAKA,EAAKpf,OAAS,GAAIue,EAAQS,EAAKV,MAAM,WAE1FtU,MAAK,SAAC9I,EAAGU,GAAJ,OAAUV,EAAEme,iBAAmBzd,EAAEyd,oBAmB3C,OAjBAN,EAAmB3c,SAAQ,WAAiB4G,GAAW,IAAzBgW,EAAwB,EAAxBA,KAAMI,EAAkB,EAAlBA,KACnB,IAATX,GAAc,EAAKlW,eAAeS,EAAQ+V,EAAmB/e,QAEjE,IAAMsf,EAAYF,EAAKA,EAAKpf,OAAS,GAC/Buf,EAAYP,EAAKjc,IACvBlC,EAAIme,EAAKjc,KAAOyZ,GAChB3b,EAAIye,GAAaN,EAAKV,KACtBU,EAAKjc,IAAMuc,EAEX,IAAME,EAAY,EAAKtB,aAAaH,EAASC,EAAY/P,EAASwQ,EAAOX,GAAMkB,EAAKV,MAAQc,EAAKpf,OAAQ0H,GACrG8X,EAAY9X,IAAOA,EAAM8X,GAE7BR,EAAKjc,IAAMwc,EACX1e,EAAIye,GAAa9C,GACjB3b,EAAIme,EAAKjc,KAAOic,EAAKV,QAGlB5W,IAxFf,kBA2FI,SAAaT,GAKT,IAJA,IAAMwY,EAAYxY,EAAMjH,OAAS,EAC3B0f,EAAazY,EAAMjH,OAASyf,EAC5BE,EAAY1Y,EAAMpG,KAAI,SAAAC,GAAC,OAAIA,EAAEiC,OAC7B6c,EAAQ,GACLze,EAAI,EAAGA,EAAIue,EAAYve,IAC5Bye,EAAMlf,KAAKif,EAAU3e,MAAMG,EAAIse,GAAYte,EAAI,GAAKse,GAAWzV,MAAK,SAAC9I,EAAGU,GAAJ,OAAUV,EAAIU,KAAGqB,KAAK,MAG9F,OAAO2c,EAAM3c,KAAK,OApG1B,wBAuGI,SAAmB8C,GAAiD,IAAD,OACzD8Z,EAAY,SACZC,EAAQ9hB,KAAK6B,WAAWmB,QACxB+e,EAAmB,CAAC,EAAG,GAChB,oBAATha,IACA+Z,EAAM3f,OAAO,EAAG,EAAG,cAAe,eAClC4f,EAAiB5f,OAAO,EAAG,EAAG,EAAG,IAErCnC,KAAKoN,MAAQ0U,EAAM,GAAG9f,OACtBhC,KAAKqN,OAASyU,EAAM9f,OACpBhC,KAAK6S,WAAa,CAAC,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,EAAE,EAAG,GAAI,CAAC,GAAI,IAAIhQ,KAAI,+BAAEC,EAAF,KAAK4F,EAAL,YAAY,EAAK4K,QAAQxQ,EAAG4F,MAErF,IAAM7F,EAAMif,EAAM/P,SAAQ,SAAA9P,GAAI,OAAIA,EAAK+f,OAAO,EAAK5U,MAAO,KAAKtL,MAAM,OAE/DmH,EAAQpG,EAAIA,KAAI,SAACyd,EAAMvb,GAAP,MAAgB,CAAEub,KAAAA,EAAMvb,IAAAA,MACzCjB,QAAO,gBAAGwc,EAAH,EAAGA,KAAH,OAAcuB,EAAU3f,KAAKoe,MACpCtU,MAAK,SAAC9I,EAAGU,GAAJ,OAAUV,EAAEod,KAAKE,cAAc5c,EAAE0c,SAErC2B,EAAiBpf,EAAIA,KAAI,SAACyd,EAAMtV,GAAP,MAAkB,CAAEsV,KAAAA,EAAMtV,MAAAA,MACpDlH,QAAO,gBAAGwc,EAAH,EAAGA,KAAMtV,EAAT,EAASA,MAAT,OACJ6W,EAAU3f,KAAKoe,IACL,MAATA,IAAiBuB,EAAU3f,KAAKW,EAAImI,EAAQ,EAAK6H,WAAW+M,SAC/D/c,KAAI,qBAAGmI,SAEP0V,EAAUuB,EAAene,QAAO,SAAA8H,GAAC,OAA0B,IAAtB,EAAKuH,QAAQvH,GAAGlD,KAErD6X,EAAUrV,OAAOC,YAAYlC,EAAMpG,KAAI,YAAe,IAAZyd,EAAW,EAAXA,KAEtCxd,EAAI,EAAgB,GADRwd,EAAK4B,WAAW,GAAK,IAEvC,MAAO,CAAC5B,EAAMyB,EAAiBlf,KAAI,SAAA6F,GAAC,OAAI,EAAK4K,QAAQxQ,EAAG4F,WAGtDkY,EAAQ9a,MAAMjD,EAAIb,QAAQ+D,KAAK,GAAGlD,KAAI,kBAAMiD,MAAMjD,EAAIb,QAAQ+D,KAAK,SASzE,OARAkc,EAAe7d,SAAQ,SAACnD,EAAOkhB,GAAa,IAAD,YACrBF,EAAejf,MAAMmf,EAAU,IADV,IACvC,2BAAqD,CAAC,IAAD,IAA1CjS,EAA0C,QAC3CkR,EAAO,EAAKgB,SAASvf,EAAK5B,EAAOiP,GACvC0Q,EAAM3f,GAAOiP,GAAb,iBAAoBkR,QAApB,IAAoBA,OAApB,EAAoBA,EAAMpe,MAAM,UAAhC,QAAsC,KACtC4d,EAAM1Q,GAAKjP,GAAX,iBAAoBmgB,QAApB,IAAoBA,OAApB,EAAoBA,EAAMiB,UAAUrf,MAAM,UAA1C,QAAgD,MAJb,kCAQpC,CACHH,IAAAA,EAAKoG,MAAAA,EAAOsX,QAAAA,EAASG,QAAAA,EAASE,MAAAA,EAC9BqB,eAAgB,IAAIpe,IAAIoe,GACxBtB,WAAY,IAAI9c,IAAI6c,MAnJhC,sBAuJI,SAAiB7d,EAAe5B,EAAeiP,GAK3C,IAJA,IAAMD,EAAU,IAAIpM,IACdye,EAAa,IAAIze,IAAI,SACrB4J,EAAQ,CAAC,CAAEjM,QAASP,EAAOmgB,KAAM,CAACngB,KAEjCwM,EAAMzL,OAAS,GAAG,CACrB,MAA0ByL,EAAMzE,QAAxBxH,EAAR,EAAQA,QAAS4f,EAAjB,EAAiBA,KACjB,GAAI5f,IAAY0O,EAAO,OAAOkR,EAFT,gBAIHphB,KAAK6S,YAJF,IAIrB,2BAAmC,CAAC,IAC1BxR,EAAOG,EADkB,SAE1ByO,EAAQlM,IAAI1C,IAASihB,EAAWve,IAAIlB,EAAIxB,MACzCoM,EAAM/K,KAAK,CAAElB,QAASH,EAAM+f,KAAK,GAAD,eAAMA,GAAN,CAAY/f,MAC5C4O,EAAQxJ,IAAIpF,KARC,+BAazB,OAAO,OAzKf,uBA4KI,SAAkBwB,GAAgB,IAAD,OACvBZ,EAAOY,EAAII,QAAO,SAACC,EAAGqP,EAAMvH,GAI9B,OAHIA,EAAQ,EAAKoC,QAAU,IACvBlK,GAAK,MAEFA,EAAIqP,IACZ,IACH7C,QAAQC,IAAI1N,KAnLpB,uBAsLI,SAAkB+Z,EAAYuG,GAC1B,IAAMtI,EAAKja,KAAKmT,QAAQ6I,GAClBf,EAAKjb,KAAKmT,QAAQoP,GACxB,OAAOha,KAAKkB,IAAIwQ,EAAGnX,EAAImY,EAAGnY,GAAKyF,KAAKkB,IAAIwQ,EAAGvR,EAAIuS,EAAGvS,KAzL1D,qBA2LI,SAAgB5F,EAAW4F,GAAqB,OAAOA,EAAI1I,KAAKoN,MAAQtK,IA3L5E,qBA4LI,SAAgBkI,GAAwB,MAAO,CAAElI,EAAGkI,EAAQhL,KAAKoN,MAAO1E,EAAGH,KAAK6F,MAAMpD,EAAQhL,KAAKoN,YA5LvG,GAA2BzN,IGV1B0C,EAAa,CACVE,IAAK,GACLC,MAAO,yBAEX,4IAEI,WACI,IAAMggB,EAAUxiB,KAAKmE,aAIrB,OAHwBnE,KAAKyiB,gBAAgBD,GAAU,GACZxW,OAAOqW,UAAU,KALpE,mBAUI,WACI,IAAMG,EAAUxiB,KAAKmE,aAIrB,OAHwBnE,KAAKyiB,gBAAgBD,EAAS,GACVxW,OAAO,KAb3D,6BAmBI,SAAwBwW,EAAwBE,GAY5C,IAZ0E,IAAD,OACzE,EAA2C,IAAdA,EAAkB,CAAC,EAAG,GAAI,GAAK,CAAC,EAAG,GAAI,GAApE,eAAOtX,EAAP,KAAauX,EAAb,KAAoBhZ,EAApB,KACMiZ,EAAWJ,EAAQvf,QAAO,SAACC,EAAGJ,GAGhC,MAFe,QAAXA,EAAEzD,MAAkB6D,EAAEA,EAAElB,OAAS,GAAGA,OAAS,GAAKkB,EAAER,KAAK,IAC7DQ,EAAEA,EAAElB,OAAS,GAAGU,KAAKI,GACdI,IACR,CAAC,KACE2f,EAAkB7iB,KAAK8iB,cAAcF,GAEvCrC,EAAiB,CAAC,CAAEpW,OAAQ,GAAI4Y,IAAK,EAAGC,GAAI,IAAInf,IAAI,CAAC,MACrDka,EAAoB,CAAC,IAAIla,IAAI,CAAC0c,EAAQ,MAEjC0C,EAAeL,EAAS5gB,OAAS,EAAGihB,GAAgB,EAAGA,IAAgB,CAC5EjjB,KAAKuK,gBAAgBqY,EAAS5gB,OAAS,EAAIihB,GAAgBL,EAAS5gB,QAIpE,IAHA,IAAMkhB,EAA8B,GAC9BC,EAA0B,GAH4C,WAKnEhjB,GACL,IANwE,eAM/DijB,GACL,IAAMC,EAAO,EAAKC,uBAAuBnjB,EAAOijB,EAAKP,EAAgBI,IAC/D9c,EAAO4X,EAAMsF,GACnB,IAAKld,EAAQ,iBATuD,gBAWlDA,GAXkD,IAWpE,2BAAwB,CAAC,IAAdsQ,EAAa,QAChB8M,EAAaL,EAAYM,MAAK,SAAA1gB,GAAC,OAAIA,EAAEqH,OAAO,KAAOhK,GAAS2C,EAAEigB,MAAQM,KACrEE,EAQDA,EAAWP,GAAGvc,IAAI2c,IAPlBG,EAAa,CACTpZ,OAAO,CAAEhK,GAAH,eAAasW,EAAItM,SACvB6Y,GAAI,IAAInf,IAAI,CAACuf,IACbL,IAAKM,GAETH,EAAYxgB,KAAK6gB,IAKhBJ,EAAUC,KAAQD,EAAUC,GAAO,IAAIvf,KAC5Csf,EAAUC,GAAK3c,IAAI8c,IAzB6C,gCAM/DH,EAAM,EAAGA,EA3CR,IA2CiCA,IAAO,EAAzCA,IADJjjB,EAAQiL,EAAMjL,IAAUwiB,EAAOxiB,GAASwJ,EAAQ,EAAhDxJ,GAyBTogB,EAAU2C,EACVnF,EAAQoF,EAGZ,OAAO5C,EAAQ1d,KAAI,SAAAC,GAAC,OAAIA,EAAEqH,OAAOlF,KAAK,SAjE9C,2BAqEI,SAAsB2d,GAClB,IADyD,EACnDrjB,EAAS,GAD0C,UAEnCqjB,GAFmC,yBAE9Ca,EAF8C,QAGrDlkB,EAAOmD,KAAK,CAAC,EAAG,EAAG,IAAIG,KAAI,SAAAC,GAAC,OAAIC,SAAU0gB,EAAQ3gB,GAAqBc,QAD3E,2BAAiC,IAFwB,8BAMzD,OAAOrE,IA3Ef,oCA+EI,SAA+BmkB,EAAWhL,EAAWiL,GACjD,cAAkBA,EAAlB,GAAOzgB,EAAP,KAAUU,EAAV,KAAa8H,EAAb,KACI5I,EAAI4V,EAAI,GAOZ,OANAA,EAAInQ,KAAK6F,MAAMsK,EAAIxV,GAGnBwV,GAAK,IADL5V,GADAA,GAAKc,KACK8f,EAAI,EAAI,GACJ,EACdhL,IAAMgL,EAAIhY,GAAK5I,IAtFvB,gCA2FI,SAA2B4V,EAAW+K,EAAwBG,EAAmCzjB,GAC7F,IAD8G,EACxG0jB,EAAS,CAAC,EAAG,EAAG,EAAGnL,GACrBoL,EAAa,EAF6F,UAGpFL,GAHoF,IAG9G,2BAAmC,CAAC,IAAzBM,EAAwB,QACN,QAArBA,EAAY1kB,KACZukB,EAASG,EAAY1kB,MAAMwkB,EAAQE,EAAY7gB,EAAG/C,EAAM2jB,MAExDF,EAASG,EAAY1kB,MAAMwkB,EAAQE,EAAY7gB,EAAG6gB,EAAYngB,IAPwC,8BAU9G,OAAOigB,EAAO,KArGtB,qBAwGI,WACI,IAAM1gB,EAAI,SAACD,GAAD,OAAeA,EAAEgf,WAAW,GAAK,KACrC/E,EAAI,SAAC7L,EAAWpO,GAAZ,uBAA0BoO,EAAEpO,EAAEgf,WAAW,GAAK,YAA9C,QAAsDnf,SAASG,IAUzE,MAAO,CAAE2gB,OAAQ,CAAC,EAAG,EAAG,EAAG,GAAID,SATW,CACtC,IAAO,SAACtS,EAAGpO,EAAGU,GAAP,OAAa0N,EAAEnO,EAAED,IAAMia,EAAE7L,EAAG1N,IACnC,IAAO,SAAC0N,EAAGpO,EAAGU,GAAP,OAAa0N,EAAEnO,EAAED,KAAOia,EAAE7L,EAAG1N,IACpC,IAAO,SAAC0N,EAAGpO,EAAGU,GAAP,OAAa0N,EAAEnO,EAAED,KAAOia,EAAE7L,EAAG1N,IACpC,IAAO,SAAC0N,EAAGpO,EAAGU,GAAP,OAAa0N,EAAEnO,EAAED,IAAMqF,KAAK6F,MAAMkD,EAAEnO,EAAED,IAAMia,EAAE7L,EAAG1N,KACxD,IAAO,SAAC0N,EAAGpO,EAAGU,GAAP,OAAa0N,EAAEnO,EAAED,KAAOia,EAAE7L,EAAG1N,IACpC,IAAO,SAAC0N,EAAGpO,EAAGU,GAAP,OAAa0N,EAAEnO,EAAED,IAAMoO,EAAEnO,EAAED,MAAQia,EAAE7L,EAAG1N,GAAK,EAAI,OAjHpE,wBAuHI,WAKI,OAJgB5D,KAAK6B,WAAWgB,KAAI,SAAAC,GAAC,OAAIA,EAAEhB,MAAM,QACxBe,KAAI,+BAAExD,EAAF,KAAQ6D,EAAR,KAAWU,EAAX,WAChB,QAATvE,EAAmC,CAAEA,KAAAA,EAAM6D,EAAAA,GAAqB,CAAE7D,KAAAA,EAAM6D,EAAAA,EAAGU,EAAAA,UA1HvF,GAA2BjE,IDbU,CAAC,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,EAAE,EAAG,GAAI,CAAC,GAAI,IAAIkD,KAAI,qCAAa,CAAEC,EAAf,KAAkB4F,EAAlB,UEGtEsb,IFDL3hB,EAAa,CACVE,IAAK,GACLC,MAAO,gBAEX,4IAEI,WAQI,IARuB,IAAD,OAChBrC,EAAQH,KAAKmE,aACXuK,EAASvO,EAATuO,KACM7L,EAAiB1C,EAAzBuO,KAAQ7L,IAAOohB,EAAU9jB,EAAV8jB,MAEjBrV,EAAO,EACPsV,EAA8B,KAC9BC,EAAY,EACTA,EAAY,GAAG,CAAC,IAAD,EAClBvV,IACAuV,EAAY,EACZF,EAAM7f,SAAQ,SAACggB,EAAMC,GACjB,IAAMC,EAA0B,CAAC,GAAI,IAC/B7Y,EAAsB3F,MAAM4I,EAAKrB,QAAQtH,KAAK,GAAGlD,KAAI,kBAAMiD,MAAM4I,EAAKtB,UACtEmX,GAAkBF,EAAY,GAAK,EACzCC,EAAUC,GAAkBN,EAAMM,GAAgBvhB,QAClDshB,EAAUC,GAAgBngB,SAAQ,SAAAwH,GAAC,OAAIH,EAAQG,EAAElD,GAAGkD,EAAE9I,GAAKyhB,KAL5B,gBAORH,GAPQ,IAO/B,2BAA6B,CAAC,IAAnBI,EAAkB,QACnBjb,EAAS,EAAK9C,IAAI+d,EAAU3R,GAAWwR,GAAY3V,GACjD5L,EAASyG,EAATzG,EAAG4F,EAAMa,EAANb,OACOzI,IAAd4C,EAAI6F,GAAG5F,IACP2I,EAAQ/C,GAAG5F,GAAKuhB,EAChBC,EAAUD,GAAW3hB,KAAK6G,GAC1B4a,MAEA1Y,EAAQ+Y,EAAS9b,GAAG8b,EAAS1hB,GAAKuhB,EAClCC,EAAUD,GAAW3hB,KAAK8hB,KAhBH,8BAmB/B3hB,EAAM4I,EACNwY,EAAQK,KAGZJ,EAAe3b,KAAKsB,IAAIsa,EAAT,UAAoBD,SAApB,QAAoC,GACnDlkB,KAAKuK,gBAAgB2Z,EAAeC,GAAaD,GAGrD,OAAOtV,IAxCf,mBA2CI,WAA4B,MAAO,MA3CvC,iBA6CI,SAAYqL,EAAWgB,EAAWvM,GAC9B,MAAO,CACH5L,GAAImX,EAAGnX,EAAImY,EAAGnY,GAAK4L,EAAKtB,MACxB1E,GAAIuR,EAAGvR,EAAIuS,EAAGvS,GAAKgG,EAAKrB,UAhDpC,uBAoDI,SAAkBxK,EAAiB6L,GAC/B,IAAK,IAAIhG,EAAI,EAAGA,EAAIgG,EAAKrB,OAAQ3E,IAAK,CAElC,IADA,IAAIzG,EAAO,GACFa,EAAI,EAAGA,EAAI4L,EAAKtB,MAAOtK,IAC5Bb,QAAsBhC,IAAd4C,EAAI6F,GAAG5F,GAAmB,IAAoB,IAAdD,EAAI6F,GAAG5F,GAAW,IAAM,IAEpE4M,QAAQC,IAAI1N,MA1DxB,wBA8DI,WACI,IAAMmL,EAAQpN,KAAK6B,WAAW,GAAGG,OAC3BqL,EAASrN,KAAK6B,WAAWG,OACzBa,EAAMiD,MAAMuH,GAAQtH,KAAK,GAAGlD,KAAI,kBAAMiD,MAAMsH,MAC5C6W,EAAmB,CAAC,GAAI,IAY9B,OAVAjkB,KAAK6B,WAAWuC,SAAQ,SAACnC,EAAMyG,GAC3BzG,EAAKH,MAAM,IAAIsC,SAAQ,SAACqgB,EAAM3hB,GAC1B,GAAa,MAAT2hB,EAAc,CACd,IAAMJ,EAAqB,MAATI,EAAe,EAAI,EACrC5hB,EAAI6F,GAAG5F,GAAKuhB,EACZJ,EAAMI,GAAW3hB,KAAK,CAAEI,EAAAA,EAAG4F,EAAAA,WAKhC,CAAEub,MAAAA,EAAOvV,KAAM,CAAE7L,IAAAA,EAAKuK,MAAAA,EAAOC,OAAAA,QA9E5C,GAA2B1N,KGIH,IAZlB+kB,WAAAA,SAAAA,KAAAA,EAAAA,EAAAA,GAAAA,KAAAA,GASD,OATCA,EAAAA,EAAAA,GAAAA,EAAAA,CAAAA,CAAAA,IAAAA,oBAAAA,MAEF,WACI,OAAO,IAAIpd,IAAIlF,EAAiBS,KAAI,SAAAP,GAAI,MAAI,CAACA,EAAKC,IAAKD,SAG3D,0BACA,WACI,OAAOwD,MAAMsF,KAAKpL,KAAK2kB,oBAAoB/hB,UAAUoJ,MAAK,SAAC9I,EAAGU,GAAJ,OAAUV,EAAEX,IAAMqB,EAAErB,WACjF,EATCmiB,KDKgBE,qBAMtBC,iBAAiB,UAAD,mCAAY,oGAAS1P,EAAT,EAASA,KAC3B9S,EAAe2hB,GAAc5d,IAAI+O,EAAK5S,KADpB,kDAIlBuiB,EAAWziB,EAAaM,UACrBoiB,KAAK5P,EAAKhV,OALK,UAOL,CAAC,EAAG,IAPC,gEAObjB,EAPa,QAQd8lB,EAAaF,EAASzkB,kBAAkBnB,GAR1B,WASdkB,EAAAA,EAAAA,GAAc4kB,EAAWC,MAC3BC,EAAAA,EAAAA,IAAI,SAAA5kB,GAAK,OAAI6kB,YAAY7kB,QAVT,+IAexB6kB,YAAY,IAAI7lB,GAAgB,EAAG,KAAM,IAfjB,gEAAZ,yDEbZ8lB,EAA2B,GAG/B,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBrlB,IAAjBslB,EACH,OAAOA,EAAaC,QAGrB,IAAIC,EAASL,EAAyBE,GAAY,CAGjDE,QAAS,IAOV,OAHAE,EAAoBJ,GAAUG,EAAQA,EAAOD,QAASH,GAG/CI,EAAOD,QAIfH,EAAoB/T,EAAIoU,EAGxBL,EAAoBviB,EAAI,WAGvB,IAAI6iB,EAAsBN,EAAoBO,OAAE3lB,EAAW,CAAC,MAAM,WAAa,OAAOolB,EAAoB,SAE1G,OADAM,EAAsBN,EAAoBO,EAAED,I,WChC7C,IAAIE,EAAW,GACfR,EAAoBO,EAAI,SAASrmB,EAAQumB,EAAUC,EAAIC,GACtD,IAAGF,EAAH,CAMA,IAAIG,EAAeC,EAAAA,EACnB,IAAS/iB,EAAI,EAAGA,EAAI0iB,EAAS7jB,OAAQmB,IAAK,CACrC2iB,EAAWD,EAAS1iB,GAAG,GACvB4iB,EAAKF,EAAS1iB,GAAG,GACjB6iB,EAAWH,EAAS1iB,GAAG,GAE3B,IAJA,IAGIgjB,GAAY,EACPpP,EAAI,EAAGA,EAAI+O,EAAS9jB,OAAQ+U,MACpB,EAAXiP,GAAsBC,GAAgBD,IAAa9a,OAAOkV,KAAKiF,EAAoBO,GAAGja,OAAM,SAASe,GAAO,OAAO2Y,EAAoBO,EAAElZ,GAAKoZ,EAAS/O,OAC3J+O,EAAS3jB,OAAO4U,IAAK,IAErBoP,GAAY,EACTH,EAAWC,IAAcA,EAAeD,IAG7C,GAAGG,EAAW,CACbN,EAAS1jB,OAAOgB,IAAK,GACrB,IAAI+G,EAAI6b,SACE9lB,IAANiK,IAAiB3K,EAAS2K,IAGhC,OAAO3K,EAzBNymB,EAAWA,GAAY,EACvB,IAAI,IAAI7iB,EAAI0iB,EAAS7jB,OAAQmB,EAAI,GAAK0iB,EAAS1iB,EAAI,GAAG,GAAK6iB,EAAU7iB,IAAK0iB,EAAS1iB,GAAK0iB,EAAS1iB,EAAI,GACrG0iB,EAAS1iB,GAAK,CAAC2iB,EAAUC,EAAIC,I,GCJ/BX,EAAoB7d,EAAI,SAASie,GAChC,IAAIW,EAASX,GAAUA,EAAOY,WAC7B,WAAa,OAAOZ,EAAgB,SACpC,WAAa,OAAOA,GAErB,OADAJ,EAAoBjb,EAAEgc,EAAQ,CAAEljB,EAAGkjB,IAC5BA,GCLRf,EAAoBjb,EAAI,SAASob,EAASc,GACzC,IAAI,IAAI5Z,KAAO4Z,EACXjB,EAAoBkB,EAAED,EAAY5Z,KAAS2Y,EAAoBkB,EAAEf,EAAS9Y,IAC5ExB,OAAOsb,eAAehB,EAAS9Y,EAAK,CAAE+Z,YAAY,EAAMrgB,IAAKkgB,EAAW5Z,MCJ3E2Y,EAAoBqB,EAAI,GAGxBrB,EAAoBsB,EAAI,SAASC,GAChC,OAAOC,QAAQC,IAAI5b,OAAOkV,KAAKiF,EAAoBqB,GAAGzjB,QAAO,SAAS8jB,EAAUra,GAE/E,OADA2Y,EAAoBqB,EAAEha,GAAKka,EAASG,GAC7BA,IACL,MCNJ1B,EAAoB2B,EAAI,SAASJ,GAEhC,MAAO,aAAeA,EAAf,sBCFRvB,EAAoB4B,SAAW,SAASL,KCDxCvB,EAAoBkB,EAAI,SAASW,EAAKC,GAAQ,OAAOjc,OAAOkc,UAAUC,eAAeC,KAAKJ,EAAKC,ICA/F9B,EAAoBzZ,EAAI,Y,WCIxB,IAAI2b,EAAkB,CACrB,IAAK,GAkBNlC,EAAoBqB,EAAEvjB,EAAI,SAASyjB,EAASG,GAEvCQ,EAAgBX,IAElBY,cAAcnC,EAAoBzZ,EAAIyZ,EAAoB2B,EAAEJ,KAK/D,IAAIa,EAAqBC,KAA0B,oBAAIA,KAA0B,qBAAK,GAClFC,EAA6BF,EAAmB/kB,KAAKklB,KAAKH,GAC9DA,EAAmB/kB,KAzBA,SAASyS,GAC3B,IAAI2Q,EAAW3Q,EAAK,GAChB0S,EAAc1S,EAAK,GACnB2S,EAAU3S,EAAK,GACnB,IAAI,IAAImQ,KAAYuC,EAChBxC,EAAoBkB,EAAEsB,EAAavC,KACrCD,EAAoB/T,EAAEgU,GAAYuC,EAAYvC,IAIhD,IADGwC,GAASA,EAAQzC,GACdS,EAAS9jB,QACdulB,EAAgBzB,EAAStX,OAAS,EACnCmZ,EAA2BxS,I,cCrB5B,IAAI9T,EAAOgkB,EAAoBviB,EAC/BuiB,EAAoBviB,EAAI,WACvB,OAAOuiB,EAAoBsB,EAAE,KAAKoB,KAAK1mB,I,GCDdgkB,EAAoBviB,I","sources":["core/solutionState.ts","core/solutionBase.ts","core/solutionInfo.ts","solutions/day01.ts","core/helpers.ts","solutions/day02.ts","solutions/day03.ts","solutions/day04.ts","solutions/day05.ts","solutions/day06.ts","solutions/day07.ts","solutions/day08.ts","solutions/day09.ts","solutions/day10.ts","solutions/day15.ts","solutions/day11.ts","solutions/day12.ts","solutions/day13.ts","solutions/day14.ts","solutions/day19.ts","solutions/day16.ts","solutions/day17.ts","solutions/day18.ts","solutions/day20.ts","solutions/day21.ts","solutions/day23.ts","solutions/day22.ts","solutions/day25.ts","solutions/day24.ts","web/services/solution.worker.ts","core/solutionManager.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["export type SolutionState = SolutionNotStarted | SolutionProgress | SolutionResult | SolutionError | SolutionCanceled;\r\n\r\nexport class SolutionNotStarted {\r\n    kind = 'not_started' as const;\r\n\r\n    constructor(\r\n        public part: number\r\n    ) { }\r\n}\r\n\r\nexport class SolutionProgress {\r\n    kind = 'progress' as const;\r\n\r\n    constructor(\r\n        public part: number,\r\n        public progress: number,\r\n        public timeMs: number = 0\r\n    ) { }\r\n}\r\n\r\nexport class SolutionResult {\r\n    kind = 'result' as const;\r\n\r\n    constructor(\r\n        public part: number,\r\n        public result: string | null,\r\n        public timeMs: number,\r\n        public visualizationData?: unknown\r\n    ) { }\r\n}\r\n\r\nexport class SolutionError {\r\n    kind = 'error' as const;\r\n\r\n    constructor(\r\n        public part: number,\r\n        public message: string,\r\n        public timeMs: number = 0\r\n    ) { }\r\n}\r\n\r\nexport class SolutionCanceled {\r\n    kind = 'canceled' as const;\r\n\r\n    constructor(\r\n        public part: number,\r\n        public timeMs: number = 0\r\n    ) { }\r\n}","import { lastValueFrom, Observable, Subscriber } from 'rxjs';\r\nimport { Stopwatch } from 'ts-stopwatch';\r\nimport { SolutionError, SolutionProgress, SolutionResult, SolutionState } from './solutionState';\r\n\r\ninterface CurrentSolution {\r\n    subscriber: Subscriber<SolutionState>;\r\n    activePart: number;\r\n    progressStopwatch: Stopwatch;\r\n    stopwatch: Stopwatch;\r\n}\r\n\r\nexport default abstract class SolutionBase {\r\n    /** Minimum elapsed milliseconds between progress updates. */\r\n    minTimeBetweenUpdatesMs = 20;\r\n\r\n    protected visualizationData?: unknown;\r\n    protected get input(): string { return this._input ?? ''; }\r\n    protected get inputLines(): string[] {\r\n        if (this._inputLines === undefined) {\r\n            this._inputLines = this.parseInputLines(this.input);\r\n        }\r\n        return this._inputLines;\r\n    }\r\n\r\n    private _input?: string;\r\n    private _inputLines?: string[];\r\n    private currentSolution?: CurrentSolution;\r\n\r\n    /**\r\n     * Initializes the solution with the given input.\r\n     * @param input \r\n     */\r\n    init(input: string): this {\r\n        this._input = input;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Solves a part asynchronously.\r\n     * @returns The result as string, or null if there was an error.\r\n     */\r\n    async solveAsync(part: 1 | 2): Promise<string | null> {\r\n        const state = await lastValueFrom(this.solveWithProgress(part));\r\n        switch (state.kind) {\r\n            case 'result': return state.result;\r\n            default: return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Solves the given part with progress updates.\r\n     * @returns Observable usable to track the solution progress.\r\n     */\r\n    solveWithProgress(part: 1 | 2): Observable<SolutionState> {\r\n        return new Observable<SolutionState>(subscriber => {\r\n            if (!this._input) {\r\n                subscriber.error(new SolutionError(part, 'No input provided!'));\r\n                return;\r\n            }\r\n            if (this.currentSolution) {\r\n                subscriber.error(new SolutionError(part, 'Another solution is already in progress!'));\r\n                return;\r\n            }\r\n\r\n            const partFunction = part === 1 ? this.part1 : this.part2;\r\n            this.currentSolution = {\r\n                activePart: part,\r\n                subscriber: subscriber,\r\n                stopwatch: new Stopwatch(),\r\n                progressStopwatch: new Stopwatch()\r\n            };\r\n            this.visualizationData = null;\r\n            this.currentSolution.stopwatch.start();\r\n            this.currentSolution.progressStopwatch.start();\r\n\r\n            try {\r\n                const result = partFunction.apply(this) + '';\r\n                const timeMs = this.currentSolution.stopwatch.stop();\r\n                const resultPack = new SolutionResult(part, result, timeMs, this.visualizationData);\r\n                subscriber.next(resultPack);\r\n            } catch (exception) {\r\n                const timeMs = this.currentSolution.stopwatch.stop() ?? 0;\r\n                subscriber.next(new SolutionError(part, exception + '', timeMs));\r\n            } finally {\r\n                subscriber.complete();\r\n                this.visualizationData = null;\r\n                this.currentSolution = undefined;\r\n            }\r\n        });\r\n    }\r\n\r\n    /** Solution for part 1. */\r\n    protected abstract part1(): string | number;\r\n\r\n    /** Solution for part 2. */\r\n    protected abstract part2(): string | number;\r\n\r\n    /**\r\n     * Updates the progress of the solution.\r\n     * @param progress Status of the progress between 0..1.\r\n     */\r\n    protected updateProgress(progress: number): void {\r\n        const current = this.currentSolution;\r\n        if (current && current.progressStopwatch.getTime() > this.minTimeBetweenUpdatesMs) {\r\n            current.subscriber.next(\r\n                new SolutionProgress(current.activePart, progress, current.stopwatch.getTime())\r\n            );\r\n            current.progressStopwatch.start(true);\r\n        }\r\n    }\r\n\r\n    /** Throws an error. Placeholder for when there is no solution yet. */\r\n    protected noSolution(msg?: string): never {\r\n        msg = msg ?? 'No solution available.';\r\n        throw new Error(msg);\r\n    }\r\n\r\n    /** Parses the input lines into a string array omitting the tailing empty lines. */\r\n    private parseInputLines(input: string): string[] {\r\n        const newLineRegex = /\\r\\n?|\\n/g;\r\n        const inputLines = input.split(newLineRegex);\r\n\r\n        let emptyCount: number;\r\n        const whiteSpaceLineRegex = /^\\s*$/gm;\r\n        for (emptyCount = 0; emptyCount < inputLines.length; emptyCount++) {\r\n            const line = inputLines[inputLines.length - emptyCount - 1];\r\n            if (!whiteSpaceLineRegex.test(line)) {\r\n                break;\r\n            }\r\n        }\r\n        inputLines.splice(inputLines.length - emptyCount, emptyCount);\r\n\r\n        return inputLines;\r\n    }\r\n}","import SolutionBase from './solutionBase';\r\n\r\nconst solutionInfoList: SolutionInfo[] = [];\r\n\r\nexport type Constructor<T> = {\r\n    new(...args: unknown[]): T;\r\n    readonly prototype: T;\r\n};\r\n\r\nexport type SolutionInfoParams = {\r\n    day: number;\r\n    title: string;\r\n};\r\n\r\nexport type SolutionInfo = SolutionInfoParams & {\r\n    ctor: Constructor<SolutionBase>;\r\n    create: () => SolutionBase;\r\n};\r\n\r\nexport function solutionInfo<TCtor extends Constructor<SolutionBase>>(day: number, title: string): (ctor: TCtor) => void;\r\nexport function solutionInfo<TCtor extends Constructor<SolutionBase>>(info: SolutionInfoParams): (ctor: TCtor) => void;\r\nexport function solutionInfo<TCtor extends Constructor<SolutionBase>>(...params: [number, string] | [SolutionInfoParams]): (ctor: TCtor) => void {\r\n    const info = typeof params[0] === 'number' ? { day: params[0], title: params[1] as string } : params[0];\r\n    return (ctor: TCtor): void => {\r\n        solutionInfoList.push({\r\n            ...info,\r\n            ctor: ctor,\r\n            create: () => new ctor()\r\n        });\r\n    };\r\n}\r\n\r\nexport { solutionInfoList };\r\n\r\n","import SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\n@solutionInfo({\r\n    day: 1,\r\n    title: 'Sonar Sweep'\r\n})\r\nexport class Day01 extends SolutionBase {\r\n\r\n    protected part1(): number {\r\n        const values = this.inputLines.map(x => parseInt(x));\r\n        const increaseCount = values.slice(1).reduce((a, x, i) => a + (values[i] < x ? 1 : 0), 0);\r\n\r\n        return increaseCount;\r\n    }\r\n\r\n    protected part2(): number {\r\n        const values = this.inputLines.map(x => parseInt(x));\r\n        const sumsOf3 = values.slice(2).map((x, i) => values[i] + values[i + 1] + x);\r\n        const increaseCount = sumsOf3.slice(1).reduce((a, x, i) => a + (sumsOf3[i] < x ? 1 : 0), 0);\r\n\r\n        return increaseCount;\r\n    }\r\n}\r\n","/**\r\n * Executes the regular expression over and over on the given text until all matches are found.\r\n * @param regex The regular expression.\r\n * @param text The text.\r\n */\r\nfunction regexMatches(regex: RegExp, text: string): RegExpExecArray[] {\r\n    const results: RegExpExecArray[] = [];\r\n    let record: RegExpExecArray | null;\r\n\r\n    while ((record = regex.exec(text))) {\r\n        results.push(record);\r\n    }\r\n\r\n    return results;\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nfunction assertNever(value: never, shouldThrow = true): void | never {\r\n    if (shouldThrow) {\r\n        throw new Error('Coding error! This path should never be reached!');\r\n    }\r\n}\r\n\r\nfunction get2DigitDay(day: number): string {\r\n    return day.toString().padStart(2, '0');\r\n}\r\n\r\n/** Performs a logical XOR operation on the two parameters. */\r\nfunction xor(a: boolean, b: boolean): boolean {\r\n    return a !== b; // (a || b) && !(a && b);\r\n}\r\n\r\nfunction intersectSets<T>(a: Set<T>, b: Set<T>): Set<T> {\r\n    return new Set([...a].filter(x => b.has(x)));\r\n}\r\n\r\nfunction toRadians(angle: number): number {\r\n    return angle * (Math.PI / 180);\r\n}\r\n\r\nexport {\r\n    assertNever,\r\n    regexMatches,\r\n    get2DigitDay,\r\n    xor,\r\n    intersectSets,\r\n    toRadians\r\n};\r\n\r\n","import { regexMatches } from '../core/helpers';\r\nimport SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\n@solutionInfo({\r\n    day: 2,\r\n    title: 'Dive!'\r\n})\r\nexport class Day02 extends SolutionBase {\r\n\r\n    protected part1(): number {\r\n        const sub = { hor: 0, dep: 0 };\r\n        this.parseInput().forEach(command => {\r\n            sub.hor += command.hor;\r\n            sub.dep += command.dep;\r\n        });\r\n\r\n        return sub.hor * sub.dep;\r\n    }\r\n\r\n    protected part2(): number {\r\n        const sub = { hor: 0, dep: 0, aim: 0 };\r\n        this.parseInput().forEach(command => {\r\n            sub.aim += command.dep;\r\n            sub.hor += command.hor;\r\n            sub.dep += sub.aim * command.hor;\r\n        });\r\n\r\n        return sub.hor * sub.dep;\r\n    }\r\n\r\n    private parseInput() {\r\n        return regexMatches(/([a-z]+) (\\d+)/g, this.input).map(match => {\r\n            const [, commandStr, valueStr] = match;\r\n            const value = parseInt(valueStr);\r\n            const command = { hor: 0, dep: 0 };\r\n            switch (commandStr) {\r\n                case 'forward': command.hor += value; break;\r\n                case 'down': command.dep += value; break;\r\n                case 'up': command.dep -= value; break;\r\n                default: throw new Error('Invalid input!');\r\n            }\r\n            return command;\r\n        });\r\n    }\r\n}\r\n","import { xor } from '../core/helpers';\r\nimport SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\ntype KeepMode = 'most_common' | 'least_common';\r\n\r\n@solutionInfo({\r\n    day: 3,\r\n    title: 'Binary Diagnostic'\r\n})\r\nexport class Day03 extends SolutionBase {\r\n\r\n    protected part1(): number {\r\n        const binaryNumbers = this.inputLines;\r\n        const halfCount = binaryNumbers.length / 2;\r\n        const bitCounts = binaryNumbers[0].split('').map((_, pos) =>\r\n            binaryNumbers.reduce((a, bNumber) => a + parseInt(bNumber[pos]), 0)\r\n        );\r\n\r\n        const gamma = parseInt(bitCounts.map(x => x >= halfCount ? '1' : '0').join(''), 2);\r\n        const epsilon = parseInt(bitCounts.map(x => x < halfCount ? '1' : '0').join(''), 2);\r\n\r\n        return gamma * epsilon;\r\n    }\r\n\r\n    protected part2(): number {\r\n        const binaryNumbers = this.inputLines;\r\n        const oxygenGeneratorRating = this.getRating(binaryNumbers, 'most_common');\r\n        const co2ScrubberRating = this.getRating(binaryNumbers, 'least_common');\r\n\r\n        return oxygenGeneratorRating * co2ScrubberRating;\r\n    }\r\n\r\n    private getRating(bNumbers: string[], keep: KeepMode): number {\r\n        for (let pos = 0; pos < bNumbers[0].length; pos++) {\r\n            bNumbers = this.filter(bNumbers, pos, keep);\r\n            if (bNumbers.length === 1) { break; }\r\n        }\r\n\r\n        return parseInt(bNumbers[0], 2);\r\n    }\r\n\r\n    private filter(bNumbers: string[], position: number, keep: KeepMode): string[] {\r\n        const bitCount = bNumbers.reduce((a, x) => a + parseInt(x[position]), 0);\r\n        const keepBit = xor(bitCount >= bNumbers.length / 2, keep === 'least_common') ? '1' : '0';\r\n\r\n        return bNumbers.filter(x => x[position] === keepBit);\r\n    }\r\n}\r\n","import { regexMatches } from '../core/helpers';\r\nimport SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\nconst boardSize = 5;\r\n\r\n@solutionInfo({\r\n    day: 4,\r\n    title: 'Giant Squid'\r\n})\r\nexport class Day04 extends SolutionBase {\r\n\r\n    protected part1(): number {\r\n        return this.playBingo('play to win');\r\n    }\r\n\r\n    protected part2(): number {\r\n        return this.playBingo('let the giant squid win');\r\n    }\r\n\r\n    private playBingo(strategy: 'play to win' | 'let the giant squid win'): number {\r\n        const { numbers, boards, lookup } = this.parseInput();\r\n        const marks: boolean[][][] = boards.map(() => Array(boardSize).fill(0).map(() => Array(boardSize).fill(false)));\r\n        const wins: Set<number> = new Set();\r\n        const targetWinCount = strategy === 'play to win' ? 1 : boards.length;\r\n\r\n        for (const calledNumber of numbers) {\r\n            const hits = lookup.get(calledNumber);\r\n            if (!hits) { continue; }\r\n\r\n            for (const { ti, tj, tk } of hits) {\r\n                marks[ti][tj][tk] = true;\r\n\r\n                if (!wins.has(ti) && this.isBingo(marks[ti], tj, tk)) {\r\n                    wins.add(ti);\r\n                    if (wins.size === targetWinCount) {\r\n                        const sum = boards[ti].reduce((boardSum, rowNumbers, row) =>\r\n                            boardSum + rowNumbers.reduce((rowSum, aNumber, col) =>\r\n                                rowSum + (marks[ti][row][col] ? 0 : aNumber), 0), 0);\r\n\r\n                        return sum * calledNumber;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this.noSolution();\r\n    }\r\n\r\n    private isBingo(board: boolean[][], hitRow: number, hitCol: number): boolean {\r\n        let row = true;\r\n        let col = true;\r\n        for (let i = 0; i < boardSize; i++) {\r\n            row &&= board[i][hitCol];\r\n            col &&= board[hitRow][i];\r\n            if (!row && !col) { return false; }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private parseInput() {\r\n        const numbers = this.parseNumbersInLine(this.inputLines[0]);\r\n        const boards: number[][][] = [];\r\n        const lookup = new Map<number, { ti: number, tj: number, tk: number; }[]>();\r\n\r\n        let lineIndex = 1;\r\n        while (lineIndex < this.inputLines.length) {\r\n            const board: number[][] = [];\r\n            const ti = boards.push(board) - 1;\r\n\r\n            let line: string;\r\n            while ((line = this.inputLines[++lineIndex])) {\r\n                const rowNumbers = this.parseNumbersInLine(line);\r\n                const tj = board.push(rowNumbers) - 1;\r\n                rowNumbers.map((n, tk) => {\r\n                    let lookupEntry = lookup.get(n);\r\n                    if (!lookupEntry) { lookup.set(n, (lookupEntry = [])); }\r\n                    lookupEntry.push({ ti, tj, tk });\r\n                });\r\n            }\r\n        }\r\n\r\n        return { numbers, boards, lookup };\r\n    }\r\n\r\n    private parseNumbersInLine(line: string): number[] {\r\n        return regexMatches(/\\d+/g, line).map(match => parseInt(match[0]));\r\n    }\r\n}\r\n","import { regexMatches } from '../core/helpers';\r\nimport SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\ninterface Pipe { x1: number; y1: number; x2: number; y2: number; }\r\n\r\n@solutionInfo({\r\n    day: 5,\r\n    title: 'Hydrothermal Venture'\r\n})\r\nexport class Day05 extends SolutionBase {\r\n\r\n    protected part1(): number {\r\n        const pipes = this.parsePipes();\r\n        const map = this.createMap(pipes, 'skip diagonals');\r\n        const overlapCount = this.countOverlaps(map);\r\n\r\n        return overlapCount;\r\n    }\r\n\r\n    protected part2(): number {\r\n        const pipes = this.parsePipes();\r\n        const map = this.createMap(pipes, 'include diagonals');\r\n        const overlapCount = this.countOverlaps(map);\r\n\r\n        return overlapCount;\r\n    }\r\n\r\n    private countOverlaps(map: number[][]): number {\r\n        return map.reduce((a, row) => a + row.reduce((a, x) => a + (x > 1 ? 1 : 0), 0), 0);\r\n    }\r\n\r\n    private createMap(pipes: Pipe[], mode: 'skip diagonals' | 'include diagonals'): number[][] {\r\n        const map: number[][] = [];\r\n        const skipDiagonals = mode === 'skip diagonals';\r\n        for (const { x1, y1, x2, y2 } of pipes) {\r\n            if (skipDiagonals && x1 !== x2 && y1 !== y2) {\r\n                continue;\r\n            }\r\n            this.drawLine(map, x1, y1, x2, y2);\r\n        }\r\n\r\n        return map;\r\n    }\r\n\r\n    private drawLine(map: number[][], x1: number, y1: number, x2: number, y2: number) {\r\n        const dx = Math.sign(x2 - x1);\r\n        const dy = Math.sign(y2 - y1);\r\n\r\n        let [x, y] = [null, null] as (number | null)[];\r\n        while (x !== x2 || y !== y2) {\r\n            x = (x ?? x1 - dx) + dx;\r\n            y = (y ?? y1 - dy) + dy;\r\n\r\n            if (map[y] === undefined) { map[y] = []; }\r\n            if (map[y][x] === undefined) { map[y][x] = 0; }\r\n            map[y][x]++;\r\n        }\r\n    }\r\n\r\n    private parsePipes(): Pipe[] {\r\n        return regexMatches(/(\\d+),(\\d+) -> (\\d+),(\\d+)/g, this.input).map(match => {\r\n            const [x1, y1, x2, y2] = match.slice(1).map(x => parseInt(x));\r\n            return { x1, y1, x2, y2 };\r\n        });\r\n    }\r\n}\r\n","import { regexMatches } from '../core/helpers';\r\nimport SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\nconst restartAge = 6;\r\nconst newBornAge = 8;\r\n\r\n@solutionInfo({\r\n    day: 6,\r\n    title: 'Lanternfish'\r\n})\r\nexport class Day06 extends SolutionBase {\r\n\r\n    protected part1(): number {\r\n        return this.simulateLanternfish(80);\r\n    }\r\n\r\n    protected part2(): number {\r\n        return this.simulateLanternfish(256);\r\n    }\r\n\r\n    private simulateLanternfish(dayCount: number): number {\r\n        const ages: number[] = Array(newBornAge + 1).fill(0);\r\n        const fishes = regexMatches(/\\d/g, this.input).map(x => parseInt(x[0]));\r\n        fishes.forEach(x => ages[x]++);\r\n\r\n        for (let day = 0; day < dayCount; day++) {\r\n            const count = ages.shift() as number;\r\n            ages[newBornAge] = count;\r\n            ages[restartAge] += count;\r\n        }\r\n\r\n        const population = ages.reduce((a, x) => a + x, 0);\r\n        return population;\r\n    }\r\n}\r\n","import { regexMatches } from '../core/helpers';\r\nimport SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\n@solutionInfo({\r\n    day: 7,\r\n    title: 'The Treachery of Whales'\r\n})\r\nexport class Day07 extends SolutionBase {\r\n\r\n    protected part1(): number {\r\n        const { crabs, minPos, maxPos } = this.parseInput();\r\n\r\n        let minMoves = Number.MAX_VALUE;\r\n        for (let target = minPos; target <= maxPos; target++) {\r\n            const moves = crabs.reduce((a, x) => a + Math.abs(x - target), 0);\r\n            minMoves = Math.min(minMoves, moves);\r\n        }\r\n\r\n        return minMoves;\r\n    }\r\n\r\n    protected part2(): number {\r\n        const { crabs, minPos, maxPos } = this.parseInput();\r\n\r\n        let minMoves = Number.MAX_VALUE;\r\n        for (let target = minPos; target <= maxPos; target++) {\r\n            const moves = crabs.reduce((a, x) => {\r\n                const delta = Math.abs(x - target);\r\n                const fuel = delta * (delta + 1) / 2;\r\n                return a + fuel;\r\n            }, 0);\r\n            minMoves = Math.min(minMoves, moves);\r\n        }\r\n\r\n        return minMoves;\r\n    }\r\n\r\n    private parseInput() {\r\n        let minPos = Number.MAX_VALUE;\r\n        let maxPos = Number.MIN_VALUE;\r\n\r\n        const crabs = regexMatches(/\\d+/g, this.input).map(x => {\r\n            const pos = parseInt(x[0]);\r\n            minPos = Math.min(minPos, pos);\r\n            maxPos = Math.max(maxPos, pos);\r\n            return pos;\r\n        });\r\n\r\n        return { crabs, minPos, maxPos };\r\n    }\r\n}\r\n","import { intersectSets, regexMatches } from '../core/helpers';\r\nimport SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\ntype Display = { patterns: string[]; digits: string[]; };\r\ntype VagueSegmentMap = { from: string; to: string[]; }[];\r\ntype SegmentMap = { [from: string]: string; };\r\ntype ReadOnlySet<T> = { has: (item: T) => boolean; };\r\n\r\nconst digitSegments: readonly string[] = ['abcefg', 'cf', 'acdeg', 'acdfg', 'bcdf', 'abdfg', 'abdefg', 'acf', 'abcdefg', 'abcdfg'];\r\nconst digitSegmentSet: ReadOnlySet<string> = new Set(digitSegments);\r\n\r\n@solutionInfo({\r\n    day: 8,\r\n    title: 'Seven Segment Search'\r\n})\r\nexport class Day08 extends SolutionBase {\r\n\r\n    protected part1(): number {\r\n        const uniqueLengths = new Set([2, 3, 4, 7]);\r\n        const displays = this.parseInput();\r\n        const uniqueCount = displays.reduce((a, r) => a +\r\n            r.digits.reduce((a, d) => a + (uniqueLengths.has(d.length) ? 1 : 0), 0), 0);\r\n\r\n        return uniqueCount;\r\n    }\r\n\r\n    protected part2(): number {\r\n        const displays = this.parseInput();\r\n        const sum = displays.reduce((a, display, i) => {\r\n            this.updateProgress(i / displays.length);\r\n            return a + this.decodeDisplayValue(display);\r\n        }, 0);\r\n\r\n        return sum;\r\n    }\r\n\r\n    /** Decodes the value shown on the display. */\r\n    private decodeDisplayValue({ patterns, digits }: Display): number {\r\n        const vagueSegmentMap = this.generateVagueSegmentMap(patterns);\r\n        const segmentMap = this.resolveSegmentMap(vagueSegmentMap, patterns);\r\n        if (!segmentMap) { this.noSolution(); }\r\n\r\n        const displayValue = parseInt(digits.map(x => this.decodeDigit(x, segmentMap)).join(''));\r\n        return displayValue;\r\n    }\r\n\r\n    /** Finds the correct mapping from the initial segment map using backtrack. */\r\n    private resolveSegmentMap(vagueMap: VagueSegmentMap, patterns: string[], index = 0): SegmentMap | null {\r\n        if (index === vagueMap.length) {\r\n            const completedMap = Object.fromEntries(vagueMap.map(x => [x.from, x.to[0]]));\r\n            return this.isSegmentMapValid(completedMap, patterns) ? completedMap : null;\r\n        }\r\n\r\n        const candidateChars = vagueMap[index].to;\r\n        for (const selectedChar of candidateChars) {\r\n            const nextMap = [\r\n                ...vagueMap.slice(0, index),\r\n                { from: vagueMap[index].from, to: [selectedChar] },\r\n                ...vagueMap.slice(index + 1).map(x => ({\r\n                    from: x.from,\r\n                    to: x.to.filter(c => c !== selectedChar)\r\n                }))\r\n            ];\r\n\r\n            const result = this.resolveSegmentMap(nextMap, patterns, index + 1);\r\n            if (result) { return result; }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** Checks if each pattern can be mapped to a digit using the segment map. */\r\n    private isSegmentMapValid(map: SegmentMap, patterns: string[]): boolean {\r\n        return patterns.every(p => digitSegmentSet.has(this.decodeSegments(p, map)));\r\n    }\r\n\r\n    /** Decodes a segment string and finds to the corresponding digit. */\r\n    private decodeDigit(segments: string, map: SegmentMap): number {\r\n        return digitSegments.indexOf(this.decodeSegments(segments, map));\r\n    }\r\n\r\n    /** Decodes an encoded segment string. */\r\n    private decodeSegments(segments: string, map: SegmentMap): string {\r\n        return segments.split('').map(x => map[x]).sort().join('');\r\n    }\r\n\r\n    /** Generates a vague segment map where each character can have multiple possible mappings. */\r\n    private generateVagueSegmentMap(patterns: string[]): VagueSegmentMap {\r\n        const digitsSegmentsByLength = new Map<number, string[][]>(Array(8).fill(0).map((_, i) => [i, []]));\r\n        digitSegments.forEach(x => digitsSegmentsByLength.get(x.length)!.push(x.split('')));\r\n\r\n        const resultMap = new Map<string, Set<string>>();\r\n        for (const pattern of patterns) {\r\n            // Generate possible segment mappings based on pattern\r\n            const patternMap = new Map<string, Set<string>>();\r\n            const validDigits = digitsSegmentsByLength.get(pattern.length)!;\r\n            pattern.split('').forEach(patternChar =>\r\n                validDigits.forEach(vd => vd.forEach(digitChar => {\r\n                    if (!patternMap.has(patternChar)) { patternMap.set(patternChar, new Set()); }\r\n                    patternMap.get(patternChar)!.add(digitChar);\r\n                }))\r\n            );\r\n\r\n            // Intersect with previous mappings\r\n            for (const [key, newChars] of patternMap.entries()) {\r\n                if (!resultMap.has(key)) {\r\n                    resultMap.set(key, newChars);\r\n                } else {\r\n                    const currentChars = resultMap.get(key)!;\r\n                    resultMap.set(key, intersectSets(currentChars, newChars));\r\n                }\r\n            }\r\n        }\r\n\r\n        // Generate sorted vague segment map\r\n        return [...resultMap.entries()]\r\n            .map(x => ({ from: x[0], to: [...x[1]] }))\r\n            .sort((a, b) => a.to.length - b.to.length);\r\n    }\r\n\r\n    private parseInput(): Display[] {\r\n        const displays = regexMatches(/(.+) \\| (.+)/g, this.input).map(displayMatch => {\r\n            const [, patternsStr, digitsStr] = displayMatch;\r\n            const patterns = regexMatches(/[a-g]+/g, patternsStr).map(x => x[0]);\r\n            const digits = regexMatches(/[a-g]+/g, digitsStr).map(x => x[0]);\r\n            return { patterns, digits };\r\n        });\r\n\r\n        return displays;\r\n    }\r\n}\r\n","import { regexMatches } from '../core/helpers';\r\nimport SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\ntype Point = { x: number; y: number; };\r\ntype HeightMap = { map: number[][]; width: number; height: number; };\r\nconst neighbors: readonly Point[] = [[-1, 0], [0, -1], [1, 0], [0, 1]].map(p => ({ x: p[0], y: p[1] }));\r\n\r\n@solutionInfo({\r\n    day: 9,\r\n    title: 'Smoke Basin'\r\n})\r\nexport class Day09 extends SolutionBase {\r\n\r\n    protected part1(): number {\r\n        const heightMap = this.parseInput();\r\n        const lowPoints = this.getLowPoints(heightMap);\r\n        const sum = lowPoints.reduce((a, p) => a + 1 + heightMap.map[p.y][p.x], 0);\r\n\r\n        return sum;\r\n    }\r\n\r\n    protected part2(): number {\r\n        const heightMap = this.parseInput();\r\n        const lowPoints = this.getLowPoints(heightMap);\r\n        const basins = lowPoints.map(p => this.flood(heightMap, p));\r\n        const largest3Basins = basins.sort((a, b) => b - a).slice(0, 3);\r\n        const product = largest3Basins.reduce((a, x) => a * x, 1);\r\n\r\n        return product;\r\n    }\r\n\r\n    private getLowPoints({ map, width, height }: HeightMap): Point[] {\r\n        const lowPoints: Point[] = [];\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const current = map[y][x];\r\n                const isLowPoint = neighbors\r\n                    .map(np => map[y + np.y] && map[y + np.y][x + np.x])\r\n                    .every(n => n === undefined || current < n);\r\n                if (isLowPoint) {\r\n                    lowPoints.push({ x, y });\r\n                }\r\n            }\r\n        }\r\n\r\n        return lowPoints;\r\n    }\r\n\r\n    /**\r\n     * Floods an area starting from the given point to calculate it's size.\r\n     * Areas are delimited by '9'-s.\r\n     */\r\n    private flood({ map, width, height }: HeightMap, start: Point): number {\r\n        const toIndex = (p: Point) => p.y * width + p.x;\r\n        const visitedIndexes = new Set<number>();\r\n        const queue: Point[] = [start];\r\n\r\n        while (queue.length > 0) {\r\n            const point = queue.shift()!;\r\n            const pointIndex = toIndex(point);\r\n\r\n            if (visitedIndexes.has(pointIndex)) { continue; }\r\n            visitedIndexes.add(pointIndex);\r\n\r\n            neighbors.forEach(np => {\r\n                const nextX = point.x + np.x;\r\n                const nextY = point.y + np.y;\r\n                if (nextX >= 0 && nextX < width &&\r\n                    nextY >= 0 && nextY < height &&\r\n                    map[nextY][nextX] < 9\r\n                ) {\r\n                    queue.push({ x: nextX, y: nextY });\r\n                }\r\n            });\r\n        }\r\n\r\n        return visitedIndexes.size;\r\n    }\r\n\r\n    private parseInput(): HeightMap {\r\n        const map = this.inputLines.map(line =>\r\n            regexMatches(/\\d/g, line).map(x => parseInt(x[0]))\r\n        );\r\n\r\n        return {\r\n            map,\r\n            width: map[0].length,\r\n            height: map.length\r\n        };\r\n    }\r\n}\r\n","import SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\nconst chunkPairs = { '(': ')', '[': ']', '{': '}', '<': '>' } as Record<string, string>;\r\nconst errorPoints = { ')': 3, ']': 57, '}': 1197, '>': 25137 } as Record<string, number>;\r\nconst completePoints = { ')': 1, ']': 2, '}': 3, '>': 4 } as Record<string, number>;\r\n\r\n@solutionInfo({\r\n    day: 10,\r\n    title: 'Syntax Scoring'\r\n})\r\nexport class Day10 extends SolutionBase {\r\n\r\n    protected part1(): number {\r\n        const errorScore = this.inputLines.reduce((a, l) => a + this.score(l, 'check'), 0);\r\n        return errorScore;\r\n    }\r\n\r\n    protected part2(): number {\r\n        const incompleteLines = this.inputLines.filter(l => !this.score(l, 'check'));\r\n        const completeScores = incompleteLines.map(l => this.score(l, 'complete'));\r\n        const middleScore = completeScores.sort((a, b) => a - b)[Math.floor(completeScores.length / 2)];\r\n\r\n        return middleScore;\r\n    }\r\n\r\n    private score(line: string, mode: 'check' | 'complete'): number {\r\n        const stack = [];\r\n        for (const actual of line.split('')) {\r\n            if (chunkPairs[actual]) {\r\n                stack.push(actual);\r\n            } else {\r\n                const chunkStart = stack.pop()!;\r\n                const expected = chunkPairs[chunkStart];\r\n                if (expected !== actual) {\r\n                    return errorPoints[actual];\r\n                }\r\n            }\r\n        }\r\n\r\n        let score = 0;\r\n        if (mode === 'complete') {\r\n            score = stack.reduceRight((a, x) => a * 5 + completePoints[chunkPairs[x]], 0);\r\n        }\r\n\r\n        return score;\r\n    }\r\n}\r\n","import { regexMatches } from '../core/helpers';\r\nimport SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\nclass Point {\r\n    constructor(public x: number, public y: number) { }\r\n    add(other: Point): Point { return new Point(this.x + other.x, this.y + other.y); }\r\n    isInBounds(width: number, height: number) { return this.x >= 0 && this.x < width && this.y >= 0 && this.y < height; }\r\n    toString(): string { return `${this.x},${this.y}`; }\r\n}\r\ntype Grid = { map: number[][]; width: number; height: number; };\r\nconst directions: readonly Point[] = [[1, 0], [0, 1], [-1, 0], [0, -1]].map(([x, y]) => new Point(x, y));\r\n\r\n@solutionInfo({\r\n    day: 15,\r\n    title: 'Chiton'\r\n})\r\nexport class Day15 extends SolutionBase {\r\n\r\n    protected part1(): number {\r\n        const grid = this.parseGrid();\r\n        const distance = this.findShortestPathLength(grid);\r\n\r\n        return distance;\r\n    }\r\n\r\n    protected part2(): string | number {\r\n        const grid = this.enlargeGrid(this.parseGrid(), 5);\r\n        const distance = this.findShortestPathLength(grid);\r\n\r\n        return distance;\r\n    }\r\n\r\n    private findShortestPathLength(grid: Grid) {\r\n        const { map, width, height } = grid;\r\n        const length = width * height;\r\n        const toIndex = (p: Point) => p.y * width + p.x;\r\n        const toPoint = (i: number) => new Point(i % width, Math.floor(i / width));\r\n        const startIndex = 0;\r\n        const endIndex = length - 1;\r\n\r\n        const nodes = Array(length).fill(0).map((_, i) => {\r\n            const p = toPoint(i);\r\n            const neighborIndexes = (directions.map(d =>\r\n                p.add(d).isInBounds(width, height) ? toIndex(p.add(d)) : undefined!\r\n            ).filter(x => x !== undefined)).sort((a, b) => a - b);\r\n\r\n            return {\r\n                index: i,\r\n                value: map[p.y][p.x],\r\n                outEdges: i === length - 1 ? [] : neighborIndexes,\r\n                shortestDistance: i === 0 ? 0 : Number.MAX_SAFE_INTEGER\r\n            };\r\n        });\r\n\r\n        let iteration = 0;\r\n        const invalidated = new Set<number>([startIndex]);\r\n        while (invalidated.size > 0) {\r\n            this.updateProgress(Math.min(iteration++ / width, .99));\r\n            const currentNodes = [...invalidated.values()].map(x => nodes[x]);\r\n            invalidated.clear();\r\n\r\n            for (const from of currentNodes) {\r\n                for (const toIndex of from.outEdges) {\r\n                    const to = nodes[toIndex];\r\n                    const distance = from.shortestDistance + to.value;\r\n                    if (distance < to.shortestDistance) {\r\n                        to.shortestDistance = distance;\r\n                        invalidated.add(to.index);\r\n                        to.outEdges.forEach(x => invalidated.add(x));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return nodes[endIndex].shortestDistance;\r\n    }\r\n\r\n    private enlargeGrid(original: Grid, times: number): Grid {\r\n        const map: number[][] = Array(original.height * times).fill(0).map(() => Array(original.width * times).fill(0));\r\n        const width = map[0].length;\r\n        const height = map.length;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const offset = Math.floor(y / original.height) + Math.floor(x / original.width);\r\n                map[y][x] = (original.map[y % original.height][x % original.width] + offset - 1) % 9 + 1;\r\n            }\r\n        }\r\n\r\n        return { map, width, height };\r\n    }\r\n\r\n    private parseGrid() {\r\n        const map = regexMatches(/\\d+/g, this.input).map(([line]) =>\r\n            line.split('').map(x => parseInt(x))\r\n        );\r\n\r\n        return { map, width: map[0].length, height: map.length };\r\n    }\r\n}\r\n","import { regexMatches } from '../core/helpers';\r\nimport SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\ntype Grid = { map: number[][]; width: number; height: number; };\r\n\r\n@solutionInfo({\r\n    day: 11,\r\n    title: 'Dumbo Octopus'\r\n})\r\nexport class Day11 extends SolutionBase {\r\n\r\n    protected part1(): number {\r\n        const grid = this.parseInput();\r\n        let flashCount = 0;\r\n        for (let step = 1; step <= 100; step++) {\r\n            flashCount += this.step(grid);\r\n        }\r\n\r\n        return flashCount;\r\n    }\r\n\r\n    protected part2(): number {\r\n        const grid = this.parseInput();\r\n        const simultaneousFlashCount = grid.width * grid.height;\r\n        let step = 1;\r\n        while (this.step(grid) < simultaneousFlashCount) {\r\n            step++;\r\n        }\r\n\r\n        return step;\r\n    }\r\n\r\n    private step(grid: Grid): number {\r\n        const { map } = grid;\r\n        let flashCount = 0;\r\n        this.forEachCell(grid, (x, y) => map[y][x]++);\r\n        this.forEachCell(grid, (x, y) => flashCount += this.flash(grid, x, y));\r\n        this.forEachCell(grid, (x, y) => map[y][x] = Math.max(0, map[y][x]));\r\n\r\n        return flashCount;\r\n    }\r\n\r\n    private flash(grid: Grid, x: number, y: number): number {\r\n        const { map } = grid;\r\n        if (map[y][x] <= 9) { return 0; }\r\n\r\n        let flashCount = 1;\r\n        map[y][x] = Number.MIN_SAFE_INTEGER;\r\n        this.forEachNeighbor(grid, x, y, (nx, ny) => {\r\n            map[ny][nx]++;\r\n            if (map[ny][nx] > 9) {\r\n                flashCount += this.flash(grid, nx, ny);\r\n            }\r\n        });\r\n\r\n        return flashCount;\r\n    }\r\n\r\n    private forEachCell({ width, height }: Grid, action: (x: number, y: number) => void): void {\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                action(x, y);\r\n            }\r\n        }\r\n    }\r\n\r\n    private forEachNeighbor({ width, height }: Grid, startX: number, startY: number, action: (x: number, y: number) => void): void {\r\n        const maxX = Math.min(width - 1, startX + 1);\r\n        const maxY = Math.min(height - 1, startY + 1);\r\n        for (let y = Math.max(0, startY - 1); y <= maxY; y++) {\r\n            for (let x = Math.max(0, startX - 1); x <= maxX; x++) {\r\n                if (x === startX && y === startY) { continue; }\r\n                action(x, y);\r\n            }\r\n        }\r\n    }\r\n\r\n    private visualize({ map }: Grid): void {\r\n        const mapStr = map\r\n            .map(line => line.map(x => x < 0 ? '-' : x > 9 ? '+' : x).join(''))\r\n            .join('\\n');\r\n        console.log(`\\n${mapStr}`);\r\n    }\r\n\r\n    private parseInput(): Grid {\r\n        const map = regexMatches(/\\d+/g, this.input).map(lineMatch =>\r\n            lineMatch[0].split('').map(x => parseInt(x))\r\n        );\r\n\r\n        return { map, width: map[0]?.length ?? 0, height: map.length };\r\n    }\r\n}\r\n","import { regexMatches } from '../core/helpers';\r\nimport SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\ntype CaveSystem = { map: Map<number, number[]>; start: number; end: number; };\r\n\r\n@solutionInfo({\r\n    day: 12,\r\n    title: 'Passage Pathing'\r\n})\r\nexport class Day12 extends SolutionBase {\r\n\r\n    protected part1(): number {\r\n        return this.findPathCount(this.parseCaveSystem(), 1);\r\n    }\r\n\r\n    protected part2(): number {\r\n        return this.findPathCount(this.parseCaveSystem());\r\n    }\r\n\r\n    private findPathCount(caveSystem: CaveSystem, repeatedCave = 0, current?: number, visited?: Set<number>): number {\r\n        const { map, start, end } = caveSystem;\r\n        if (!current || !visited) {\r\n            return this.findPathCount(caveSystem, repeatedCave, start, new Set([start]));\r\n        }\r\n\r\n        let pathCount = 0;\r\n        const options = map.get(current)!;\r\n        for (const next of options) {\r\n            if (next === start) { continue; }\r\n\r\n            let nextRepeatedCave = repeatedCave;\r\n            if (next < 0 && visited.has(next)) {\r\n                if (nextRepeatedCave) { continue; }\r\n                nextRepeatedCave = next;\r\n            }\r\n\r\n            visited.add(next);\r\n            if (next === end) {\r\n                pathCount++;\r\n            } else {\r\n                pathCount += this.findPathCount(caveSystem, nextRepeatedCave, next, visited);\r\n            }\r\n            if (nextRepeatedCave !== next) { visited.delete(next); }\r\n        }\r\n\r\n        return pathCount;\r\n    }\r\n\r\n    /** Creates a map of caves where small caves are <0 and large caves are >0. */\r\n    private parseCaveSystem(): CaveSystem {\r\n        let caveCount = 0;\r\n        const connections = regexMatches(/(\\w+)-(\\w+)/g, this.input).map(([, a, b]) => [a, b]);\r\n        const caves = [...new Set(connections.flat())];\r\n        const caveIds = Object.fromEntries(caves.map(c => [c, ++caveCount * (c[0].toUpperCase() === c[0] ? 1 : -1)]));\r\n        const map = new Map<number, number[]>(caves.map(x => [caveIds[x], []]));\r\n        for (const [a, b] of connections) {\r\n            map.get(caveIds[a])!.push(caveIds[b]);\r\n            map.get(caveIds[b])!.push(caveIds[a]);\r\n        }\r\n\r\n        return { map, start: caveIds['start'], end: caveIds['end'] };\r\n    }\r\n}\r\n","import { regexMatches } from '../core/helpers';\r\nimport SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\ntype Point = { x: number; y: number; };\r\nexport type Day13VisualizationData = { steps: { points: Point[]; fold?: Point; }[]; };\r\n\r\n@solutionInfo({\r\n    day: 13,\r\n    title: 'Transparent Origami'\r\n})\r\nexport class Day13 extends SolutionBase {\r\n    protected visualizationData?: Day13VisualizationData;\r\n\r\n    protected part1(): number {\r\n        const manual = this.parseInput();\r\n        const points = this.fold(manual.points, manual.folds[0]);\r\n\r\n        return points.length;\r\n    }\r\n\r\n    protected part2(): string {\r\n        this.visualizationData = { steps: [] };\r\n        const manual = this.parseInput();\r\n        const points = manual.folds.reduce((points, fold) => {\r\n            this.visualizationData!.steps.push({ points, fold });\r\n            return this.fold(points, fold);\r\n        }, manual.points);\r\n        this.visualizationData!.steps.push({ points });\r\n        const code = this.draw(points);\r\n\r\n        return code;\r\n    }\r\n\r\n    private fold(points: Point[], fold: Point): Point[] {\r\n        const duplicates = new Set<string>();\r\n        const foldedPoints = points.map(p => ({\r\n            x: fold.x && p.x > fold.x ? p.x - (p.x - fold.x) * 2 : p.x,\r\n            y: fold.y && p.y > fold.y ? p.y - (p.y - fold.y) * 2 : p.y\r\n        })).filter(p => {\r\n            const pointStr = `${p.x},${p.y}`;\r\n            return duplicates.has(pointStr) ? false : duplicates.add(pointStr);\r\n        });\r\n\r\n        return foldedPoints;\r\n    }\r\n\r\n    private draw(points: Point[]): string {\r\n        const width = points.reduce((a, p) => Math.max(a, p.x), -1) + 1;\r\n        const height = points.reduce((a, p) => Math.max(a, p.y), -1) + 1;\r\n        const image = Array(height).fill(0).map(() => Array(width).fill(' '));\r\n        points.forEach(p => image[p.y][p.x] = '');\r\n\r\n        return image.map(line => line.join('')).join('\\n');\r\n    }\r\n\r\n    private parseInput() {\r\n        const points = regexMatches(/(\\d+),(\\d+)/g, this.input).map(m => ({ x: parseInt(m[1]), y: parseInt(m[2]) }));\r\n        const folds = regexMatches(/fold along ([xy])=(\\d+)/g, this.input)\r\n            .map(m => {\r\n                const axis = m[1] as 'x' | 'y';\r\n                const pos = parseInt(m[2]);\r\n                return {\r\n                    x: axis === 'x' ? pos : 0,\r\n                    y: axis === 'y' ? pos : 0\r\n                };\r\n            });\r\n\r\n        return { points, folds };\r\n    }\r\n}\r\n","import { regexMatches } from '../core/helpers';\r\nimport SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\ntype Rule = { pair: string; newLetter: string; newPairs: string[]; };\r\n\r\n@solutionInfo({\r\n    day: 14,\r\n    title: 'Extended Polymerization'\r\n})\r\nexport class Day14 extends SolutionBase {\r\n\r\n    protected part1(): number {\r\n        const { template, rules } = this.parseInput();\r\n        const { leastCommonCount, mostCommonCount } = this.runSteps(template, rules, 10);\r\n\r\n        return mostCommonCount - leastCommonCount;\r\n    }\r\n\r\n    protected part2(): number {\r\n        const { template, rules } = this.parseInput();\r\n        const { leastCommonCount, mostCommonCount } = this.runSteps(template, rules, 40);\r\n\r\n        return mostCommonCount - leastCommonCount;\r\n    }\r\n\r\n    private runSteps(template: string, rules: Rule[], stepCount: number) {\r\n        const letters = [...new Set(rules.flatMap(x => [x.newLetter, ...x.pair.split('')]))];\r\n        const letterCounts = Object.fromEntries(letters.map(x => [x, 0]));\r\n        const pairCombinations = letters.flatMap(a => letters.map(b => a + b));\r\n        const pairCounts = Object.fromEntries(pairCombinations.map(x => [x, 0]));\r\n        const ruleMap = Object.fromEntries(rules.map(rule => ([rule.pair, rule])));\r\n\r\n        // Populate letter and combination counts from template\r\n        template.split('').forEach((char, i, templateArray) => {\r\n            letterCounts[char]++;\r\n            if (i < templateArray.length - 1) {\r\n                pairCounts[char + templateArray[i + 1]]++;\r\n            }\r\n        });\r\n\r\n        // Run steps\r\n        for (let step = 0; step < stepCount; step++) {\r\n            for (const [pair, count] of Object.entries(pairCounts)) {\r\n                const { newPairs, newLetter } = ruleMap[pair];\r\n                letterCounts[newLetter] += count;\r\n                pairCounts[pair] -= count;\r\n                newPairs.forEach(newPair => pairCounts[newPair] += count);\r\n            }\r\n        }\r\n\r\n        // Read commonality\r\n        const letterCountsAscending = Object.entries(letterCounts)\r\n            .map(([char, count]) => ({ char, count }))\r\n            .sort((a, b) => a.count - b.count);\r\n        const leastCommonCount = letterCountsAscending[0].count;\r\n        const mostCommonCount = letterCountsAscending[letterCountsAscending.length - 1].count;\r\n\r\n        return { mostCommonCount, leastCommonCount };\r\n    }\r\n\r\n    private parseInput() {\r\n        const template = this.input.match(/^\\w+/m)?.[0] ?? '';\r\n        const rules = regexMatches(/(\\w{2}) -> (\\w)/g, this.input)\r\n            .map(([, pair, newLetter]) => ({\r\n                pair,\r\n                newLetter,\r\n                newPairs: [pair[0] + newLetter, newLetter + pair[1]]\r\n            }));\r\n\r\n        return { template, rules };\r\n    }\r\n}\r\n","import { regexMatches, toRadians } from '../core/helpers';\r\nimport SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\nclass Point {\r\n    constructor(public x: number, public y: number, public z: number) { }\r\n\r\n    add(p: Point): Point { return new Point(this.x + p.x, this.y + p.y, this.z + p.z); }\r\n    sub(p: Point): Point { return new Point(this.x - p.x, this.y - p.y, this.z - p.z); }\r\n    manhattan(p: Point): number { return Math.abs(this.x - p.x) + Math.abs(this.y - p.y) + Math.abs(this.z - p.z); }\r\n    equal(p: Point): boolean { return this.x === p.x && this.y === p.y && this.z === p.z; }\r\n\r\n    toString(): string { return `${this.x},${this.y},${this.z}`; }\r\n\r\n    vector(): Matrix { return [[this.x], [this.y], [this.z]]; }\r\n    static from(vector: Matrix): Point {\r\n        const [[x], [y], [z]] = vector;\r\n        return new Point(x, y, z);\r\n    }\r\n}\r\n\r\ntype Matrix = number[][];\r\ntype Scanner = { id: number, points: Point[]; relativeDistances: number[][]; offset: Point; };\r\ntype Overlap = { p1Index: number, p2Index: number; };\r\nconst origin = new Point(0, 0, 0);\r\nconst overlapThreshold = 12 as const;\r\n\r\n@solutionInfo({\r\n    day: 19,\r\n    title: 'Beacon Scanner'\r\n})\r\nexport class Day19 extends SolutionBase {\r\n\r\n    rotations: Matrix[] = this.createRotationMatrixes();\r\n    orientedScanners: Scanner[] = [];\r\n\r\n    protected part1(): number {\r\n        const scanners = this.parseInput();\r\n        const pairs = this.unorderedPairs(scanners)\r\n            .map(([a, b], index, arr) => {\r\n                this.updateProgress(index / arr.length);\r\n                return { a, b, overlap: this.overlap(a, b) as Overlap };\r\n            })\r\n            .filter(p => p.overlap)\r\n            .flatMap(p => [p, { // add reversed pairs as well\r\n                a: p.b, b: p.a,\r\n                overlap: { p1Index: p.overlap.p2Index, p2Index: p.overlap.p1Index }\r\n            }]);\r\n\r\n        const oriented = new Set<number>([0]);\r\n        while (oriented.size < scanners.length) {\r\n            const pairIndex = pairs.findIndex(p => oriented.has(p.a.id) && !oriented.has(p.b.id));\r\n            const { a, b, overlap } = pairs[pairIndex];\r\n            this.reorient(a, b, overlap);\r\n            oriented.add(b.id);\r\n            pairs.splice(pairIndex, 1);\r\n        }\r\n        this.orientedScanners = scanners;\r\n\r\n        const pointSet = new Set<string>();\r\n        scanners.forEach(s => s.points.forEach(p => pointSet.add(p.toString())));\r\n\r\n        return pointSet.size;\r\n    }\r\n\r\n    protected part2(): number {\r\n        const maxDistance = this.unorderedPairs(this.orientedScanners)\r\n            .reduce((max, [a, b]) => Math.max(max, a.offset.manhattan(b.offset)),\r\n                Number.MIN_SAFE_INTEGER);\r\n\r\n        return maxDistance;\r\n    }\r\n\r\n    /** Reorients s2 using s1 as origin based on the given overlap data. */\r\n    private reorient(s1: Scanner, s2: Scanner, overlap: Overlap): boolean {\r\n        const { p1Index, p2Index } = overlap;\r\n        const p1 = s1.points[p1Index];\r\n        for (const rotation of this.rotations) {\r\n            const rotatedPoints = s2.points.map(p => Point.from(this.multiply(rotation, p.vector())));\r\n            const offset = p1.sub(rotatedPoints[p2Index]);\r\n            const offsetPoints = rotatedPoints.map(p => p.add(offset));\r\n\r\n            const overlapCount = offsetPoints.reduce((a, p) => a + (s1.points.some(s1p => s1p.equal(p)) ? 1 : 0), 0);\r\n            if (overlapCount >= overlapThreshold) {\r\n                s2.points = offsetPoints;\r\n                s2.offset = offset;\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** Creates unordered pair combinations of the given items. */\r\n    private unorderedPairs<T>(items: T[]): [T, T][] {\r\n        const length = items.length;\r\n        const pairs: [T, T][] = [];\r\n        for (let i = 0; i < length; i++) {\r\n            const a = items[i];\r\n            for (let j = i + 1; j < length; j++) {\r\n                pairs.push([a, items[j]]);\r\n            }\r\n        }\r\n\r\n        return pairs;\r\n    }\r\n\r\n    /**\r\n     * Finds an overlap between two scanners by comparing relative distances of points within each.\r\n     * Returning only the first hit is not 100% accurate, but good enough for the puzzle.\r\n     * */\r\n    private overlap(s1: Scanner, s2: Scanner): Overlap | false {\r\n        for (let i = 0; i < s1.relativeDistances.length; i++) {\r\n            const r1 = s1.relativeDistances[i];\r\n            for (let j = 0; j < s2.relativeDistances.length; j++) {\r\n                const r2 = s2.relativeDistances[j];\r\n                const overlap = this.intersectSorted(r1, r2);\r\n                if (overlap.length >= overlapThreshold - 1) {\r\n                    return { p1Index: i, p2Index: j };\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** Returns the intersection of two ascending number arrays. */\r\n    private intersectSorted(a: number[], b: number[]): number[] {\r\n        const result: number[] = [];\r\n        let bIndex = 0;\r\n        for (const item of a) {\r\n            while (b[bIndex] < item) { bIndex++; }\r\n            if (b[bIndex] === item) {\r\n                result.push(item);\r\n                bIndex++;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private parseInput(): Scanner[] {\r\n        const scannerMatches = regexMatches(/--- scanner (\\d+) ---\\r?\\n((?:.*,.*,.*(?:\\r?\\n)?)*)/g, this.input);\r\n        const scanners = scannerMatches.map(([, idGroup, pointsGroup]) => {\r\n            const id = parseInt(idGroup);\r\n            const points = regexMatches(/(-?\\d+),(-?\\d+),(-?\\d+)/g, pointsGroup)\r\n                .map(m => m.slice(1).map(x => parseInt(x)))\r\n                .map(([x, y, z]) => new Point(x, y, z));\r\n            const relativeDistances = points.map(p1 => points.map(p2 => p1.manhattan(p2)).sort((a, b) => a - b).slice(1));\r\n            return { id, points, relativeDistances, offset: origin };\r\n        });\r\n\r\n        return scanners;\r\n    }\r\n\r\n    // Matrixes\r\n\r\n    /** Creates rotation matrixes for each possible 90-based orientation. */\r\n    private createRotationMatrixes(): Matrix[] {\r\n        // Individual rotations on each axes\r\n        const rotationAngles: readonly number[] = [0, 90, 180, 270].map(d => toRadians(d));\r\n        const xrs = rotationAngles.map(a => this.Rx(a));\r\n        const yrs = rotationAngles.map(a => this.Ry(a));\r\n        const zrs = rotationAngles.map(a => this.Rz(a));\r\n\r\n        // Rotation combinations\r\n        const duplicates = new Set<string>();\r\n        const rotations = xrs\r\n            .flatMap(rx => yrs.map(ry => [rx, ry]))\r\n            .flatMap(([rx, ry]) => zrs.map(rz => [rx, ry, rz]))\r\n            .map(t => t.reduce((a, x) => this.multiply(a, x)))\r\n            .filter(t => !duplicates.has(t.join(';')) && duplicates.add(t.join(';')));\r\n\r\n        return rotations;\r\n    }\r\n\r\n    /** Multiplies the 2 matrixes. */\r\n    private multiply(m1: Matrix, m2: Matrix) {\r\n        const height = m1.length;\r\n        const width = m2[0].length;\r\n        const result: Matrix = Array(height).fill(0).map(() => Array(width));\r\n        for (let row = 0; row < height; row++) {\r\n            for (let col = 0; col < width; col++) {\r\n                result[row][col] = m1[row].map((x1, i1) => x1 * m2[i1][col]).reduce((a, x) => a + x);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // Rotation matrix generators for each axes\r\n    private Rx(r: number): Matrix { return this.intMatrix([[1, 0, 0], [0, Math.cos(r), -Math.sin(r)], [0, Math.sin(r), Math.cos(r)]]); }\r\n    private Ry(r: number): Matrix { return this.intMatrix([[Math.cos(r), 0, Math.sin(r)], [0, 1, 0], [-Math.sin(r), 0, Math.cos(r)]]); }\r\n    private Rz(r: number): Matrix { return this.intMatrix([[Math.cos(r), -Math.sin(r), 0], [Math.sin(r), Math.cos(r), 0], [0, 0, 1]]); }\r\n\r\n    /** Converts matrix values into integers. */\r\n    private intMatrix(matrix: Matrix) { return matrix.map(line => line.map(x => x < 0 ? Math.ceil(x) : Math.floor(x))); }\r\n}\r\n","import { regexMatches } from '../core/helpers';\r\nimport SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\ntype LiteralPacket = { kind: 'literal'; version: number; value: number; };\r\ntype OperatorPacket = { kind: 'operator'; version: number; operator: number; packets: Packet[]; };\r\ntype Packet = LiteralPacket | OperatorPacket;\r\n\r\n@solutionInfo({\r\n    day: 16,\r\n    title: 'Packet Decoder'\r\n})\r\nexport class Day16 extends SolutionBase {\r\n\r\n    protected part1(): number {\r\n        const { flatPackets } = this.parseInput();\r\n        return flatPackets.reduce((a, x) => a + x.version, 0);\r\n    }\r\n\r\n    protected part2(): number {\r\n        const { rootPacket } = this.parseInput();\r\n        return this.evaluate(rootPacket);\r\n    }\r\n\r\n    private evaluate(packet: Packet): number {\r\n        if (packet.kind === 'literal') {\r\n            return packet.value;\r\n        }\r\n\r\n        const packets = packet.packets;\r\n        switch (packet.operator) {\r\n            case 0: return packets.reduce((a, x) => a + this.evaluate(x), 0); // sum\r\n            case 1: return packets.reduce((a, x) => a * this.evaluate(x), 1); // product\r\n            case 2: return packets.map(x => this.evaluate(x)).reduce((a, x) => x < a ? x : a); // minimum\r\n            case 3: return packets.map(x => this.evaluate(x)).reduce((a, x) => x > a ? x : a); // maximum\r\n            case 5: return this.evaluate(packets[0]) > this.evaluate(packets[1]) ? 1 : 0; // greater than\r\n            case 6: return this.evaluate(packets[0]) < this.evaluate(packets[1]) ? 1 : 0; // less than\r\n            case 7: return this.evaluate(packets[0]) === this.evaluate(packets[1]) ? 1 : 0; // equal\r\n            default: throw new Error(`Invalid operator: ${packet.operator}`);\r\n        }\r\n    }\r\n\r\n    private parseInput() {\r\n        const hex = /[0-9A-F]+/.exec(this.input)?.[0] ?? '';\r\n        const binary = hex.split('').map(x => parseInt(x, 16).toString(2).padStart(4, '0')).join('');\r\n        const flatPackets: Packet[] = [];\r\n        return { rootPacket: this.parsePacket(binary, flatPackets).packet, flatPackets };\r\n    }\r\n\r\n    private parsePacket(binary: string, flatPackets: Packet[]) {\r\n        const literalPacket = /^(?<version>\\d{3})100(?<data>(?:1\\d{4})*0\\d{4})/;\r\n        const lengthPacketHeader = /^(?<version>\\d{3})(?<operator>(?!100)\\d{3})0(?<length>\\d{15})/;\r\n        const countPacketHeader = /^(?<version>\\d{3})(?<operator>(?!100)\\d{3})1(?<count>\\d{11})/;\r\n\r\n        let match: RegExpExecArray | null;\r\n        if ((match = literalPacket.exec(binary))) {\r\n            return this.parseLiteralPacket(match, flatPackets);\r\n        } else if ((match = lengthPacketHeader.exec(binary))) {\r\n            return this.parseOperatorPacket(binary, match, flatPackets);\r\n        } else if ((match = countPacketHeader.exec(binary))) {\r\n            return this.parseOperatorPacket(binary, match, flatPackets);\r\n        }\r\n\r\n        throw new Error(`Unknown packet format: ${binary}`);\r\n    }\r\n\r\n    private parseLiteralPacket(match: RegExpExecArray, flatPackets: Packet[]) {\r\n        const { version, data } = match.groups!;\r\n        const packet: LiteralPacket = {\r\n            kind: 'literal',\r\n            version: parseInt(version, 2),\r\n            value: parseInt(regexMatches(/\\d{5}/g, data).map(x => x[0].slice(1)).join(''), 2)\r\n        };\r\n        flatPackets.push(packet);\r\n\r\n        return { packet, length: match[0].length };\r\n    }\r\n\r\n    private parseOperatorPacket(binary: string, match: RegExpExecArray, flatPackets: Packet[]) {\r\n        const { version, operator, length, count } = match.groups!;\r\n        const headerLength = match[0].length;\r\n        const packet: OperatorPacket = {\r\n            kind: 'operator',\r\n            version: parseInt(version, 2),\r\n            operator: parseInt(operator, 2),\r\n            packets: []\r\n        };\r\n        flatPackets.push(packet);\r\n\r\n        const parseInnerPacket = (from: number) => {\r\n            const { packet: innerPacket, length: innerLength } = this.parsePacket(binary.slice(from), flatPackets);\r\n            packet.packets.push(innerPacket);\r\n            return innerLength;\r\n        };\r\n\r\n        let packetLength = headerLength;\r\n        if (length !== undefined) {\r\n            const innerLengthTotal = parseInt(length, 2);\r\n            while (packetLength - headerLength < innerLengthTotal) { packetLength += parseInnerPacket(packetLength); }\r\n        } else {\r\n            const packetCount = parseInt(count, 2);\r\n            for (let i = 0; i < packetCount; i++) { packetLength += parseInnerPacket(packetLength); }\r\n        }\r\n\r\n        return { packet, length: packetLength };\r\n    }\r\n}\r\n","import SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\ntype Point = { x: number; y: number; };\r\ntype Simulation = { hit: boolean, missTop: number, missBottom: number; };\r\n\r\n@solutionInfo({\r\n    day: 17,\r\n    title: 'Trick Shot'\r\n})\r\nexport class Day17 extends SolutionBase {\r\n\r\n    protected part1(): number {\r\n        const { topLeft, bottomRight } = this.parseInput();\r\n        const { maxY } = this.searchMaxY(topLeft, bottomRight);\r\n\r\n        return maxY;\r\n    }\r\n\r\n    protected part2(): number {\r\n        const { bottomRight, topLeft } = this.parseInput();\r\n        const { maxAy } = this.searchMaxY(topLeft, bottomRight);\r\n        const minAy = bottomRight.y;\r\n\r\n        let hitCount = 0;\r\n        for (let aY = minAy; aY <= maxAy; aY++) {\r\n            for (let aX = 0; aX <= bottomRight.x; aX++) {\r\n                if (this.isHit(aX, aY, topLeft, bottomRight)) {\r\n                    hitCount++;\r\n                }\r\n            }\r\n        }\r\n\r\n        return hitCount;\r\n    }\r\n\r\n    private isHit(aX: number, aY: number, tl: Point, br: Point) {\r\n        let x = 0;\r\n        let y = 0;\r\n        while (!((aY < 0 && y < br.y) || x > br.x || (aX === 0 && x < tl.x))) {\r\n            x += aX;\r\n            y += aY;\r\n            if (x >= tl.x && x <= br.x && y >= br.y && y <= tl.y) {\r\n                return true;\r\n            }\r\n            aX = Math.max(0, aX - 1);\r\n            aY = aY - 1;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private searchMaxY(tl: Point, br: Point) {\r\n        let maxAy = -1;\r\n        let canGoHigher = true;\r\n        let prev: Simulation = undefined!;\r\n        let maxY = Number.MIN_SAFE_INTEGER;\r\n        while (canGoHigher) {\r\n            maxAy++;\r\n            const simulation = this.simulateY(maxAy, tl, br);\r\n            if (simulation.hit) { maxY = Math.max(maxY, simulation.maxY); }\r\n            canGoHigher = simulation.hit || !prev || !(!prev.hit &&\r\n                prev.missTop <= simulation.missTop &&\r\n                prev.missBottom >= simulation.missBottom);\r\n            prev = simulation;\r\n        }\r\n\r\n        return { maxAy, maxY };\r\n    }\r\n\r\n    private simulateY(maxAy: number, tl: Point, br: Point) {\r\n        let y = 0;\r\n        let aY = maxAy;\r\n        let hit = false;\r\n        let missTop = 0;\r\n        let missBottom = 0;\r\n        let maxY = Number.MIN_SAFE_INTEGER;\r\n        while (!((aY < 0 && y < br.y))) {\r\n            y += aY;\r\n            maxY = Math.max(maxY, y);\r\n            if (y >= br.y && y <= tl.y) {\r\n                hit = true;\r\n                break;\r\n            }\r\n            if (y > tl.y) { missTop = y; }\r\n            aY = aY - 1;\r\n        }\r\n        if (y < br.y) { missBottom = y; }\r\n\r\n        return { hit, missTop, missBottom, maxY };\r\n    }\r\n\r\n    private parseInput() {\r\n        const [x1, x2, y1, y2] = (this.input\r\n            .match(/target area: x=(-?\\d+)\\.\\.(-?\\d+), y=(-?\\d+)\\.\\.(-?\\d+)/) ?? [])\r\n            .slice(1).map(x => parseInt(x));\r\n\r\n        return { topLeft: { x: x1, y: y2 }, bottomRight: { x: x2, y: y1 } };\r\n    }\r\n}\r\n","import SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\ntype SnailGroup = {\r\n    kind: 'group';\r\n    items: SnailNumber[];\r\n    parent?: SnailGroup;\r\n    sideInParent?: 0 | 1;\r\n};\r\n\r\ntype SnailValue = {\r\n    kind: 'value';\r\n    value: number;\r\n    parent: SnailGroup;\r\n    sideInParent: 0 | 1;\r\n};\r\n\r\ntype SnailNumber = SnailGroup | SnailValue;\r\n\r\n@solutionInfo({\r\n    day: 18,\r\n    title: 'Snailfish'\r\n})\r\nexport class Day18 extends SolutionBase {\r\n\r\n    protected part1(): number {\r\n        const numbers = this.parseInput();\r\n        const sum = numbers.reduce((a, x) => this.add(a, x));\r\n        const magnitude = this.magnitude(sum);\r\n\r\n        return magnitude;\r\n    }\r\n\r\n    protected part2(): number {\r\n        let maxMagnitude = Number.MIN_SAFE_INTEGER;\r\n        const numbers = this.parseInput();\r\n        for (let i = 0; i < this.inputLines.length; i++) {\r\n            this.updateProgress(i / this.inputLines.length);\r\n            for (let j = 0; j < this.inputLines.length; j++) {\r\n                if (i === j) { continue; }\r\n                const a = this.clone(numbers[i]);\r\n                const b = this.clone(numbers[j]);\r\n                const magnitude = this.magnitude(this.add(a, b));\r\n                maxMagnitude = Math.max(maxMagnitude, magnitude);\r\n            }\r\n        }\r\n\r\n        return maxMagnitude;\r\n    }\r\n\r\n    private magnitude(sn: SnailNumber): number {\r\n        if (sn.kind === 'value') { return sn.value; }\r\n        return this.magnitude(sn.items[0]) * 3 + this.magnitude(sn.items[1]) * 2;\r\n    }\r\n\r\n    private add(sn1: SnailNumber, sn2: SnailNumber): SnailGroup {\r\n        const result: SnailGroup = this.createSnailGroup([sn1, sn2]);\r\n        result.items.forEach((sn, i) => {\r\n            sn.parent = result;\r\n            sn.sideInParent = i as 0 | 1;\r\n        });\r\n\r\n        let isReduceNeeded = true;\r\n        while (isReduceNeeded) {\r\n            isReduceNeeded = this.explodeIfNeeded(result);\r\n            if (isReduceNeeded) { continue; }\r\n            isReduceNeeded = this.splitIfNeeded(result);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private splitIfNeeded(sn: SnailNumber): boolean {\r\n        if (sn.kind === 'value') {\r\n            if (sn.value >= 10) {\r\n                this.split(sn);\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        return sn.items.some(child => this.splitIfNeeded(child));\r\n    }\r\n\r\n    private explodeIfNeeded(sn: SnailNumber, level = 0): boolean {\r\n        if (sn.kind === 'value') { return false; }\r\n\r\n        if (level === 4) {\r\n            this.explode(sn);\r\n            return true;\r\n        }\r\n\r\n        return sn.items.some(child => this.explodeIfNeeded(child, level + 1));\r\n    }\r\n\r\n    private explode(sn: SnailGroup): void {\r\n        for (const side of [0, 1] as const) {\r\n            const sibling = this.findValueSibling(sn.items[side] as SnailValue, side);\r\n            if (sibling) { sibling.value += (sn.items[side] as SnailValue).value; }\r\n        }\r\n\r\n        if (!sn.parent) { throw new Error('No parent for exploding pair!'); }\r\n        sn.parent.items[sn.sideInParent!] = this.createSnailValue(0, sn.parent, sn.sideInParent!);\r\n    }\r\n\r\n    private split(sv: SnailValue): void {\r\n        const sg = sv as unknown as SnailGroup; // Convert into group\r\n        sg.kind = 'group';\r\n        sg.items = [Math.floor(sv.value / 2), Math.ceil(sv.value / 2)]\r\n            .map((value, sideInParent) => this.createSnailValue(value, sg, sideInParent));\r\n    }\r\n\r\n    private findValueSibling(sv: SnailValue, side: 0 | 1): SnailValue | null {\r\n        // go up until we can step towards the given side\r\n        let sn: SnailNumber = sv;\r\n        let sibling: SnailNumber | undefined = undefined;\r\n        while (!sibling) {\r\n            if (!sn.parent) { return null; }\r\n            if (sn.sideInParent !== side) {\r\n                sibling = sn.parent.items[side];\r\n            } else {\r\n                sn = sn.parent;\r\n            }\r\n        }\r\n\r\n        // Go down until we find a value\r\n        const sideInverse = side === 0 ? 1 : 0;\r\n        while (sibling.kind !== 'value') {\r\n            sibling = sibling.items[sideInverse];\r\n        }\r\n\r\n        return sibling;\r\n    }\r\n\r\n    private parseInput(): SnailNumber[] {\r\n        return this.inputLines.map(line => this.parseSnailNumber(line));\r\n    }\r\n\r\n    private parseSnailNumber(text: string): SnailNumber {\r\n        const stack: SnailGroup[] = [];\r\n        let prevPair: SnailGroup;\r\n        let pair: SnailGroup = this.createSnailGroup([]);\r\n        for (const char of text) {\r\n            switch (char) {\r\n                case '[':\r\n                    prevPair = pair;\r\n                    stack.push(prevPair);\r\n                    pair = this.createSnailGroup([], prevPair, prevPair.items.length);\r\n                    prevPair.items.push(pair);\r\n                    break;\r\n                case ']': pair = stack.pop()!; break;\r\n                case ',': break;\r\n                default: pair.items.push(this.createSnailValue(parseInt(char), pair, pair.items.length)); break;\r\n            }\r\n        }\r\n\r\n        pair.items[0].parent = undefined;\r\n        return pair.items[0];\r\n    }\r\n\r\n    private clone(sn: SnailNumber, parent?: SnailGroup): SnailNumber {\r\n        parent ??= sn.parent;\r\n        if (sn.kind === 'value') {\r\n            return this.createSnailValue(sn.value, parent!, sn.sideInParent);\r\n        }\r\n\r\n        const clonedGroup = this.createSnailGroup([], parent, sn.sideInParent);\r\n        sn.items.forEach(x => clonedGroup.items.push(this.clone(x, clonedGroup)));\r\n\r\n        return clonedGroup;\r\n    }\r\n\r\n    private createSnailGroup(items: SnailNumber[], parent?: SnailGroup, sideInParent?: number): SnailGroup {\r\n        return <SnailGroup>{ kind: 'group', items, parent, sideInParent };\r\n    }\r\n\r\n    private createSnailValue(value: number, parent: SnailGroup, sideInParent: number): SnailValue {\r\n        return <SnailValue>{ kind: 'value', value, parent, sideInParent };\r\n    }\r\n}\r\n","import SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\ntype Image = Record<number, Record<number, string>>;\r\n\r\n@solutionInfo({\r\n    day: 20,\r\n    title: 'Trench Map'\r\n})\r\nexport class Day20 extends SolutionBase {\r\n\r\n    isInfiniteLit = false;\r\n\r\n    protected part1(): number {\r\n        const { image, algorithm } = this.parseInput();\r\n        const result = this.enhance(image, algorithm, 2);\r\n\r\n        return this.boundaries(result).pixelCount;\r\n    }\r\n\r\n    protected part2(): number {\r\n        const { image, algorithm } = this.parseInput();\r\n        const result = this.enhance(image, algorithm, 50);\r\n\r\n        return this.boundaries(result).pixelCount;\r\n    }\r\n\r\n    private enhance(image: Image, algorithm: string, count: number) {\r\n        this.isInfiniteLit = false;\r\n        const isInfiniteFlashing = algorithm[0] === '1';\r\n\r\n        for (let i = 0; i < count; i++) {\r\n            this.updateProgress(i / count);\r\n            const { startX, startY, endX, endY } = this.boundaries(image);\r\n            const next: Image = {};\r\n\r\n            for (let y = startY - 1; y <= endY + 1; y++) {\r\n                for (let x = startX - 1; x <= endX + 1; x++) {\r\n                    const value = algorithm[this.algorithmIndex(image, x, y)];\r\n                    this.set(next, x, y, value);\r\n                }\r\n            }\r\n\r\n            image = next;\r\n            this.isInfiniteLit = isInfiniteFlashing && !this.isInfiniteLit;\r\n        }\r\n\r\n        return image;\r\n    }\r\n\r\n    private algorithmIndex(image: Image, x: number, y: number) {\r\n        const indexArray: string[] = [];\r\n        for (let j = y - 1; j <= y + 1; j++) {\r\n            for (let i = x - 1; i <= x + 1; i++) {\r\n                indexArray.push(this.get(image, i, j));\r\n            }\r\n        }\r\n\r\n        return parseInt(indexArray.join(''), 2);\r\n    }\r\n\r\n    private parseInput() {\r\n        const newLineRegex = /\\r?\\n/g;\r\n        const [, algorithmMatch, imageMatch] = this.input.match(/((?:.+(?:\\r?\\n)?)+)\\r?\\n\\r?\\n((?:.+(?:\\r?\\n)?)+)/) ?? [];\r\n        const algorithm = algorithmMatch.replace(newLineRegex, '').replace(/\\./g, '0').replace(/#/g, '1');\r\n        const image: Image = {};\r\n        imageMatch.split(newLineRegex)\r\n            .forEach((line, y) => line.split('')\r\n                .forEach(((v, x) => this.set(image, x, y, v === '#' ? '1' : '0'))));\r\n\r\n        return { algorithm, image };\r\n    }\r\n\r\n    private set(image: Image, x: number, y: number, value: string) {\r\n        if (image[y] === undefined) { image[y] = {}; }\r\n        image[y][x] = value;\r\n    }\r\n\r\n    private get(image: Image, x: number, y: number): string {\r\n        const row = image[y];\r\n        if (row === undefined || row[x] === undefined) { return this.isInfiniteLit ? '1' : '0'; }\r\n        return row[x];\r\n    }\r\n\r\n    private boundaries(image: Image) {\r\n        let [startX, startY, endX, endY, pixelCount] = [0, 0, 0, 0, 0];\r\n        Object.entries(image).forEach(([y, row]) => Object.entries(row).map(([x, v]) => {\r\n            if (v === '1') {\r\n                startX = Math.min(startX, parseInt(x));\r\n                startY = Math.min(startY, parseInt(y));\r\n                endX = Math.max(endX, parseInt(x));\r\n                endY = Math.max(endY, parseInt(y));\r\n                pixelCount++;\r\n            }\r\n        }));\r\n        return { startX, startY, endX, endY, pixelCount };\r\n    }\r\n\r\n    private visualize(image: Image) {\r\n        const { startX, startY, endX, endY } = this.boundaries(image);\r\n        console.log({ startX, startY, endX, endY });\r\n        for (let y = startY; y <= endY; y++) {\r\n            let line = '';\r\n            for (let x = startX; x <= endX; x++) {\r\n                line += this.get(image, x, y) === '1' ? '#' : '.';\r\n            }\r\n            console.log(line);\r\n        }\r\n    }\r\n}\r\n","import { regexMatches } from '../core/helpers';\r\nimport SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\nconst boardSize = 10;\r\nconst rollsPerTurn = 3;\r\n\r\n@solutionInfo({\r\n    day: 21,\r\n    title: 'Dirac Dice'\r\n})\r\nexport class Day21 extends SolutionBase {\r\n\r\n    protected part1(): number {\r\n        const players = this.parseInput();\r\n        const winningPoints = 1000;\r\n        const diceSides = 100;\r\n\r\n        let playerIndex = 1;\r\n        let diceValue = 1;\r\n        let rollCount = 0;\r\n        while (players[playerIndex].points < winningPoints) {\r\n            let rollResult = 0;\r\n            for (let i = 0; i < rollsPerTurn; i++) {\r\n                rollResult += (diceValue++ - 1) % diceSides + 1;\r\n                rollCount++;\r\n            }\r\n\r\n            playerIndex = (playerIndex + 1) % 2;\r\n            const player = players[playerIndex];\r\n            player.pos = (player.pos + rollResult - 1) % boardSize + 1;\r\n            player.points += player.pos;\r\n        }\r\n\r\n        return players[(playerIndex + 1) % 2].points * rollCount;\r\n    }\r\n\r\n    protected part2(): number {\r\n        const players = this.parseInput();\r\n        const wins = this.countWins(0, players[0].pos, players[0].points, players[1].pos, players[1].points);\r\n\r\n        return Math.max(wins.p1, wins.p2);\r\n    }\r\n\r\n    private countWins(player: number, pos1: number, score1: number, pos2: number, score2: number, cache?: Map<number, { p1: number; p2: number; }>): { p1: number, p2: number; } {\r\n        cache ??= new Map();\r\n        const hash = this.hash(player, pos1, score1, pos2, score2);\r\n        const wins = { p1: 0, p2: 0 };\r\n        const winningScore = 21;\r\n\r\n        if (score1 >= winningScore) {\r\n            wins.p1 = 1; cache.set(hash, wins);\r\n        } else if (score2 >= winningScore) {\r\n            wins.p2 = 1; cache.set(hash, wins);\r\n        }\r\n\r\n        const cached = cache.get(hash);\r\n        if (cached) { return cached; }\r\n\r\n        const dimensionsByRoll = [[3, 1], [4, 3], [5, 6], [6, 7], [7, 6], [8, 3], [9, 1]];\r\n        for (const [roll, dimensions] of dimensionsByRoll) {\r\n            if (player == 0) {\r\n                const nextPos1 = (pos1 + roll - 1) % boardSize + 1;\r\n                const nextScore1 = score1 + nextPos1;\r\n                const { p1, p2 } = this.countWins(1, nextPos1, nextScore1, pos2, score2, cache);\r\n                wins.p1 += dimensions * p1;\r\n                wins.p2 += dimensions * p2;\r\n            } else {\r\n                const nextPos2 = (pos2 + roll - 1) % boardSize + 1;\r\n                const nextScore2 = score2 + nextPos2;\r\n                const { p1, p2 } = this.countWins(0, pos1, score1, nextPos2, nextScore2, cache);\r\n                wins.p1 += dimensions * p1;\r\n                wins.p2 += dimensions * p2;\r\n            }\r\n        }\r\n\r\n        cache.set(hash, wins);\r\n        return wins;\r\n    }\r\n\r\n    private hash(player: number, pos1: number, score1: number, pos2: number, score2: number) {\r\n        return (((player * 100 + pos1) * 100 + score1) * 100 + pos2) * 100 + score2;\r\n    }\r\n\r\n    private parseInput() {\r\n        return regexMatches(/Player (\\d) starting position: (\\d+)/g, this.input)\r\n            .map(match => ({\r\n                id: parseInt(match[1]),\r\n                pos: parseInt(match[2]),\r\n                points: 0\r\n            }));\r\n    }\r\n}\r\n","import SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\ntype Point = { x: number; y: number; };\r\ntype Crab = { type: string; pos: number; };\r\ntype MapInfo = {\r\n    map: string[];\r\n    crabs: Crab[];\r\n    validPositions: Set<number>,\r\n    hallway: number[],\r\n    hallwaySet: Set<number>,\r\n    targets: Record<string, number[]>;\r\n    paths: (number[] | null)[][];\r\n};\r\n\r\nconst EMPTY = '.' as const;\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nconst [RIGHT, DOWN, LEFT, UP] = [0, 1, 2, 3] as const;\r\nconst costs: Record<string, number> = { 'A': 1, 'B': 10, 'C': 100, 'D': 1000 } as const;\r\n\r\n@solutionInfo({\r\n    day: 23,\r\n    title: 'Amphipod'\r\n})\r\nexport class Day23 extends SolutionBase {\r\n    private width = 0;\r\n    private height = 0;\r\n    private directions: number[] = [];\r\n\r\n    protected part1(): number {\r\n        const mapInfo = this.parseInput('as normal');\r\n        const targetHash = this.getTargetHash(mapInfo);\r\n        const shortest = this.findCheapest(mapInfo, targetHash);\r\n\r\n        return shortest;\r\n    }\r\n\r\n    protected part2(): number {\r\n        const mapInfo = this.parseInput('add extra lines');\r\n        const targetHash = this.getTargetHash(mapInfo);\r\n        const shortest = this.findCheapest(mapInfo, targetHash);\r\n\r\n        return shortest;\r\n    }\r\n\r\n    private getTargetHash(mapInfo: MapInfo) {\r\n        const targetIndexes = Object.fromEntries(Object.keys(costs).map(k => [k, 0]));\r\n        const targetHash = this.hash(mapInfo.crabs\r\n            .map(c => ({ type: c.type, pos: mapInfo.targets[c.type][targetIndexes[c.type]++] }))\r\n            .sort((a, b) => a.type.localeCompare(b.type))\r\n        );\r\n\r\n        return targetHash;\r\n    }\r\n\r\n    private findCheapest(mapInfo: MapInfo, targetHash: string, visited = new Map<string, number>(), cost = 0, min = Number.MAX_SAFE_INTEGER): number {\r\n        if (cost >= min) { return min; }\r\n\r\n        const { map, crabs, hallway, hallwaySet, targets, paths } = mapInfo;\r\n        const hash = this.hash(crabs);\r\n        const visitedCost = visited.get(hash);\r\n        if (visitedCost !== undefined && visitedCost <= cost) { return min; }\r\n        visited.set(hash, cost);\r\n        if (hash === targetHash) { return cost; }\r\n\r\n        const crabPositionsSet = new Set(crabs.map(x => x.pos));\r\n        const crabMoveCandidates = crabs\r\n            .map((crab) => {\r\n                const { type, pos } = crab;\r\n                let targetCandidates: number[] = [];\r\n                if (hallwaySet.has(pos)) {\r\n                    // Move into target room if there is room available and no crab of different type is in the room\r\n                    if (targets[type].every(p => map[p] === EMPTY || map[p] === type)) {\r\n                        const target = targets[type].filter(p => map[p] === EMPTY)[0]; // fills bottom up\r\n                        if (target !== undefined) { targetCandidates = [target]; }\r\n                    }\r\n                } else {\r\n                    // Move out of the room to the hallway, if no other crab is blocking it\r\n                    if (map[crab.pos + this.directions[UP]] === EMPTY && !targets[crab.type].every(p => map[p] === crab.type)) {\r\n                        targetCandidates = hallway.filter(p => map[p] === EMPTY);\r\n                    }\r\n                }\r\n\r\n                const validCandidates = targetCandidates\r\n                    .map(candidate => paths[crab.pos][candidate] as number[])\r\n                    .filter(path => path !== null && path.every(p => !crabPositionsSet.has(p)));\r\n\r\n                return { crab, paths: validCandidates };\r\n            })\r\n            .filter(x => x && x.paths.length > 0)\r\n            .flatMap(({ crab, paths }) => paths.map(path => ({\r\n                crab, path, distanceToTarget: this.manhattan(path[path.length - 1], targets[crab.type][0])\r\n            })))\r\n            .sort((a, b) => a.distanceToTarget - b.distanceToTarget); // prefer to go in or be closer to target\r\n\r\n        crabMoveCandidates.forEach(({ crab, path }, index) => {\r\n            if (cost === 0) { this.updateProgress(index / crabMoveCandidates.length); }\r\n\r\n            const targetPos = path[path.length - 1];\r\n            const posBefore = crab.pos;\r\n            map[crab.pos] = EMPTY;\r\n            map[targetPos] = crab.type;\r\n            crab.pos = targetPos;\r\n\r\n            const totalCost = this.findCheapest(mapInfo, targetHash, visited, cost + costs[crab.type] * path.length, min);\r\n            if (totalCost < min) { min = totalCost; }\r\n\r\n            crab.pos = posBefore;\r\n            map[targetPos] = EMPTY;\r\n            map[crab.pos] = crab.type;\r\n        });\r\n\r\n        return min;\r\n    }\r\n\r\n    private hash(crabs: { pos: number; }[]): string {\r\n        const groupSize = crabs.length / 4;\r\n        const groupCount = crabs.length / groupSize;\r\n        const positions = crabs.map(x => x.pos);\r\n        const parts = [];\r\n        for (let i = 0; i < groupCount; i++) {\r\n            parts.push(positions.slice(i * groupSize, (i + 1) * groupSize).sort((a, b) => a - b).join(';'));\r\n        }\r\n\r\n        return parts.join('|');\r\n    }\r\n\r\n    private parseInput(mode: 'as normal' | 'add extra lines'): MapInfo {\r\n        const crabRegex = /[ABCD]/;\r\n        const lines = this.inputLines.slice();\r\n        const targetYPositions = [3, 2];\r\n        if (mode === 'add extra lines') {\r\n            lines.splice(3, 0, '  #D#C#B#A#', '  #D#B#A#C#');\r\n            targetYPositions.splice(0, 0, 5, 4);\r\n        }\r\n        this.width = lines[0].length;\r\n        this.height = lines.length;\r\n        this.directions = [[1, 0], [0, 1], [-1, 0], [0, -1]].map(([x, y]) => this.toIndex(x, y));\r\n\r\n        const map = lines.flatMap(line => line.padEnd(this.width, ' ').split(''));\r\n\r\n        const crabs = map.map((type, pos) => ({ type, pos }))\r\n            .filter(({ type }) => crabRegex.test(type))\r\n            .sort((a, b) => a.type.localeCompare(b.type));\r\n\r\n        const validPositions = map.map((type, index) => ({ type, index }))\r\n            .filter(({ type, index }) =>\r\n                crabRegex.test(type) ||\r\n                (type === '.' && !crabRegex.test(map[index + this.directions[DOWN]]))\r\n            ).map(({ index }) => index);\r\n\r\n        const hallway = validPositions.filter(p => this.toPoint(p).y === 1);\r\n\r\n        const targets = Object.fromEntries(crabs.map(({ type }) => {\r\n            const typeIndex = type.charCodeAt(0) - 65;\r\n            const x = 3 + typeIndex * 2;\r\n            return [type, targetYPositions.map(y => this.toIndex(x, y))];\r\n        }));\r\n\r\n        const paths = Array(map.length).fill(0).map(() => Array(map.length).fill(null));\r\n        validPositions.forEach((start, vpIndex) => {\r\n            for (const end of validPositions.slice(vpIndex + 1)) {\r\n                const path = this.findPath(map, start, end);\r\n                paths[start][end] = path?.slice(1) ?? null;\r\n                paths[end][start] = path?.reverse().slice(1) ?? null;\r\n            }\r\n        });\r\n\r\n        return {\r\n            map, crabs, targets, hallway, paths,\r\n            validPositions: new Set(validPositions),\r\n            hallwaySet: new Set(hallway)\r\n        };\r\n    }\r\n\r\n    private findPath(map: string[], start: number, end: number): number[] | null {\r\n        const visited = new Set<number>();\r\n        const validCells = new Set('.ABCD');\r\n        const queue = [{ current: start, path: [start] as number[] }];\r\n\r\n        while (queue.length > 0) {\r\n            const { current, path } = queue.shift()!;\r\n            if (current === end) { return path; }\r\n\r\n            for (const dir of this.directions) {\r\n                const next = current + dir;\r\n                if (!visited.has(next) && validCells.has(map[next])) {\r\n                    queue.push({ current: next, path: [...path, next] });\r\n                    visited.add(next);\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private visualize(map: string[]) {\r\n        const line = map.reduce((a, char, index) => {\r\n            if (index % this.width === 0) {\r\n                a += '\\n';\r\n            }\r\n            return a + char;\r\n        }, '');\r\n        console.log(line);\r\n    }\r\n\r\n    private manhattan(i1: number, i2: number): number {\r\n        const p1 = this.toPoint(i1);\r\n        const p2 = this.toPoint(i2);\r\n        return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\r\n    }\r\n    private toIndex(x: number, y: number): number { return y * this.width + x; }\r\n    private toPoint(index: number): Point { return { x: index % this.width, y: Math.floor(index / this.width) }; }\r\n}\r\n","import { regexMatches } from '../core/helpers';\r\nimport SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\ntype Cube = {\r\n    x1: number; x2: number;\r\n    y1: number; y2: number;\r\n    z1: number; z2: number;\r\n    volume: number;\r\n};\r\ntype Step = { cube: Cube, state: boolean; };\r\ntype PunchedCube = {\r\n    base: Cube;\r\n    state: boolean;\r\n    holes: PunchedCube[];\r\n};\r\n\r\n@solutionInfo({\r\n    day: 22,\r\n    title: 'Reactor Reboot'\r\n})\r\nexport class Day22 extends SolutionBase {\r\n\r\n    protected part1(): number {\r\n        const { initSteps } = this.parseInput();\r\n        return this.executeSteps(initSteps);\r\n    }\r\n\r\n    protected part2(): number {\r\n        const { steps } = this.parseInput();\r\n        return this.executeSteps(steps);\r\n    }\r\n\r\n    private executeSteps(steps: Step[]): number {\r\n        const reCubes: PunchedCube[] = [];\r\n        steps.forEach(({ cube, state }, index) => {\r\n            this.updateProgress(index / steps.length);\r\n\r\n            const intersections = reCubes\r\n                .map(reCube => ({ reCube, hole: this.intersectPunched(reCube, cube) as PunchedCube }))\r\n                .filter(x => x.hole);\r\n\r\n            for (const { reCube, hole } of intersections) {\r\n                hole.state = false;\r\n                reCube.holes.push(hole);\r\n            }\r\n\r\n            if (state) {\r\n                reCubes.push({ state: state, base: cube, holes: [] });\r\n            }\r\n        });\r\n\r\n        return reCubes.reduce((a, x) => a + this.volume(x), 0);\r\n    }\r\n\r\n    private intersectPunched(a: PunchedCube, b: Cube): PunchedCube | false {\r\n        const base = this.intersect(a.base, b);\r\n        if (!base) { return false; }\r\n        const holes = a.holes.map(h => this.intersectPunched(h, b) as PunchedCube).filter(x => x);\r\n\r\n        return { base, holes, state: !a.state };\r\n    }\r\n\r\n    private volume(reCube: PunchedCube): number {\r\n        let volume = reCube.base.volume;\r\n        for (const hole of reCube.holes) {\r\n            volume -= this.volume(hole);\r\n        }\r\n\r\n        return volume;\r\n    }\r\n\r\n    private intersect(a: Cube, b: Cube): Cube | false {\r\n        const x1 = Math.max(a.x1, b.x1);\r\n        const x2 = Math.min(a.x2, b.x2);\r\n        const y1 = Math.max(a.y1, b.y1);\r\n        const y2 = Math.min(a.y2, b.y2);\r\n        const z1 = Math.max(a.z1, b.z1);\r\n        const z2 = Math.min(a.z2, b.z2);\r\n        if (x1 > x2 || y1 > y2 || z1 > z2) { return false; }\r\n\r\n        return this.createCube(x1, x2, y1, y2, z1, z2);\r\n    }\r\n\r\n    private parseInput() {\r\n        const cubes = regexMatches(/(on|off) x=(-?\\d+)\\.\\.(-?\\d+),y=(-?\\d+)\\.\\.(-?\\d+),z=(-?\\d+)\\.\\.(-?\\d+)/g, this.input)\r\n            .map(([, onOffMatch, ...coordMatches]) => {\r\n                const state = onOffMatch === 'on';\r\n                const coords = coordMatches.map(x => parseInt(x));\r\n                const isInitStep = coords.every(x => x >= -50 && x <= 50);\r\n                const [x1, x2, y1, y2, z1, z2] = coords;\r\n                const cube = this.createCube(x1, x2, y1, y2, z1, z2);\r\n\r\n                return { isInitStep, state, cube, holes: [] };\r\n            });\r\n\r\n        return { steps: cubes as Step[], initSteps: cubes.filter(x => x.isInitStep) };\r\n    }\r\n\r\n    private createCube(x1: number, x2: number, y1: number, y2: number, z1: number, z2: number) {\r\n        return { x1, x2, y1, y2, z1, z2, volume: (x2 - x1 + 1) * (y2 - y1 + 1) * (z2 - z1 + 1) };\r\n    }\r\n}\r\n","import SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\ntype Point = { x: number; y: number; };\r\ntype Grid = { map: number[][]; width: number; height: number; };\r\nconst directions: readonly Point[] = [[1, 0], [0, 1], [-1, 0], [0, -1]].map(([x, y]) => ({ x, y }));\r\n\r\n@solutionInfo({\r\n    day: 25,\r\n    title: 'Sea Cucumber'\r\n})\r\nexport class Day25 extends SolutionBase {\r\n\r\n    protected part1(): number {\r\n        const input = this.parseInput();\r\n        const { grid } = input;\r\n        let { grid: { map }, herds } = input;\r\n\r\n        let step = 0;\r\n        let maxMoveCount: number | null = null;\r\n        let moveCount = 1;\r\n        while (moveCount > 0) {\r\n            step++;\r\n            moveCount = 0;\r\n            herds.forEach((herd, herdIndex) => {\r\n                const nextHerds: typeof herds = [[], []];\r\n                const nextMap: typeof map = Array(grid.height).fill(0).map(() => Array(grid.width));\r\n                const otherHerdIndex = (herdIndex + 1) % 2;\r\n                nextHerds[otherHerdIndex] = herds[otherHerdIndex].slice();\r\n                nextHerds[otherHerdIndex].forEach(p => nextMap[p.y][p.x] = otherHerdIndex);\r\n\r\n                for (const cucumber of herd) {\r\n                    const target = this.add(cucumber, directions[herdIndex], grid);\r\n                    const { x, y } = target;\r\n                    if (map[y][x] === undefined) {\r\n                        nextMap[y][x] = herdIndex;\r\n                        nextHerds[herdIndex].push(target);\r\n                        moveCount++;\r\n                    } else {\r\n                        nextMap[cucumber.y][cucumber.x] = herdIndex;\r\n                        nextHerds[herdIndex].push(cucumber);\r\n                    }\r\n                }\r\n                map = nextMap;\r\n                herds = nextHerds;\r\n            });\r\n\r\n            maxMoveCount = Math.max(moveCount, maxMoveCount ?? 0);\r\n            this.updateProgress((maxMoveCount - moveCount) / maxMoveCount);\r\n        }\r\n\r\n        return step;\r\n    }\r\n\r\n    protected part2(): string { return '*'; }\r\n\r\n    private add(p1: Point, p2: Point, grid: Grid): Point {\r\n        return {\r\n            x: (p1.x + p2.x) % grid.width,\r\n            y: (p1.y + p2.y) % grid.height\r\n        };\r\n    }\r\n\r\n    private visualize(map: number[][], grid: Grid) {\r\n        for (let y = 0; y < grid.height; y++) {\r\n            let line = '';\r\n            for (let x = 0; x < grid.width; x++) {\r\n                line += map[y][x] === undefined ? '.' : map[y][x] === 0 ? '>' : 'v';\r\n            }\r\n            console.log(line);\r\n        }\r\n    }\r\n\r\n    private parseInput() {\r\n        const width = this.inputLines[0].length;\r\n        const height = this.inputLines.length;\r\n        const map = Array(height).fill(0).map(() => Array(width));\r\n        const herds: Point[][] = [[], []];\r\n\r\n        this.inputLines.forEach((line, y) => {\r\n            line.split('').forEach((cell, x) => {\r\n                if (cell !== '.') {\r\n                    const herdIndex = cell === '>' ? 0 : 1;\r\n                    map[y][x] = herdIndex;\r\n                    herds[herdIndex].push({ x, y });\r\n                }\r\n            });\r\n        });\r\n\r\n        return { herds, grid: { map, width, height } };\r\n    }\r\n}\r\n","import SolutionBase from '../core/solutionBase';\r\nimport { solutionInfo } from '../core/solutionInfo';\r\n\r\ntype InputInstruction = { kind: 'inp'; a: string; };\r\ntype OpInstruction = { kind: 'add' | 'mul' | 'div' | 'mod' | 'eql'; a: string; b: string; };\r\ntype Instruction = OpInstruction | InputInstruction;\r\n\r\ntype Memory = [number, number, number, number];\r\ntype Command = (m: Memory, a: string, b: string) => void;\r\ntype ALU = { memory: Memory, commands: Record<string, Command>; };\r\ntype Hit = { digits: number[]; out: number; in: Set<number>; };\r\n\r\nconst BRUTE_FORCE_MAX_Z = 1000000;\r\n\r\n@solutionInfo({\r\n    day: 24,\r\n    title: 'Arithmetic Logic Unit'\r\n})\r\nexport class Day24 extends SolutionBase {\r\n\r\n    protected part1(): string | number {\r\n        const program = this.parseInput();\r\n        const possibleNumbers = this.findModelNumber(program, -1);\r\n        const largestModelNumber = possibleNumbers.sort().reverse()[0];\r\n\r\n        return largestModelNumber;\r\n    }\r\n\r\n    protected part2(): string | number {\r\n        const program = this.parseInput();\r\n        const possibleNumbers = this.findModelNumber(program, 1);\r\n        const smallestModelNumber = possibleNumbers.sort()[0];\r\n\r\n        return smallestModelNumber;\r\n    }\r\n\r\n\r\n    private findModelNumber(program: Instruction[], direction: 1 | -1): string[] {\r\n        const [from, until, delta] = direction === 1 ? [1, 10, 1] : [9, 0, -1];\r\n        const sections = program.reduce((a, x) => {\r\n            if (x.kind === 'inp' && a[a.length - 1].length > 0) { a.push([]); }\r\n            a[a.length - 1].push(x);\r\n            return a;\r\n        }, [[]] as Instruction[][]);\r\n        const paramsBySection = this.extractParams(sections);\r\n\r\n        let targets: Hit[] = [{ digits: [], out: 0, in: new Set([0]) }];\r\n        let cache: Set<Hit>[] = [new Set([targets[0]])];\r\n\r\n        for (let sectionIndex = sections.length - 1; sectionIndex >= 0; sectionIndex--) {\r\n            this.updateProgress((sections.length - 1 - sectionIndex) / sections.length);\r\n            const nextTargets: typeof targets = [];\r\n            const nextCache: typeof cache = [];\r\n\r\n            for (let input = from; input !== until; input += delta) {\r\n                for (let zIn = 0; zIn < BRUTE_FORCE_MAX_Z; zIn++) {\r\n                    const zOut = this.executeCompiledSection(input, zIn, paramsBySection[sectionIndex]);\r\n                    const hits = cache[zOut];\r\n                    if (!hits) { continue; }\r\n\r\n                    for (const hit of hits) {\r\n                        let nextTarget = nextTargets.find(x => x.digits[0] === input && x.out === zOut);\r\n                        if (!nextTarget) {\r\n                            nextTarget = {\r\n                                digits: [input, ...hit.digits],\r\n                                in: new Set([zIn]),\r\n                                out: zOut\r\n                            };\r\n                            nextTargets.push(nextTarget);\r\n                        } else {\r\n                            nextTarget.in.add(zIn);\r\n                        }\r\n\r\n                        if (!nextCache[zIn]) { nextCache[zIn] = new Set(); }\r\n                        nextCache[zIn].add(nextTarget);\r\n                    }\r\n                }\r\n            }\r\n\r\n            targets = nextTargets;\r\n            cache = nextCache;\r\n        }\r\n\r\n        return targets.map(x => x.digits.join(''));\r\n    }\r\n\r\n    /** Extract the 3 variable parts of each section, derived by hand analysis. */\r\n    private extractParams(sections: Instruction[][]): number[][] {\r\n        const result = [];\r\n        for (const section of sections) {\r\n            result.push([4, 5, 15].map(x => parseInt((section[x] as OpInstruction).b)));\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /** \"Compiled\" by hand, lol */\r\n    private executeCompiledSection(w: number, z: number, params: number[]) {\r\n        const [a, b, c] = params;\r\n        let x = z % 26;\r\n        z = Math.floor(z / a); //   1|  1|  1| 26|  1| 26| 26|  1|  1|  1| 26| 26| 26| 26\r\n        x += b;                //  10| 14| 14|-13| 10|-13| -7| 11| 10| 13| -4| -9|-13| -9\r\n        x = x !== w ? 1 : 0;\r\n        z *= 25 * x + 1;\r\n        z += (w + c) * x;      //   2| 13| 13|  9| 15|  3|  6|  5| 16|  1|  6|  3|  7|  9\r\n\r\n        return z;\r\n    }\r\n\r\n    private executeInterpreted(z: number, section: Instruction[], commands: Record<string, Command>, input: string[]) {\r\n        const memory = [0, 0, 0, z] as Memory;\r\n        let inputIndex = 0;\r\n        for (const instruction of section) {\r\n            if (instruction.kind === 'inp') {\r\n                commands[instruction.kind](memory, instruction.a, input[inputIndex++]);\r\n            } else {\r\n                commands[instruction.kind](memory, instruction.a, instruction.b);\r\n            }\r\n        }\r\n        return memory[3];\r\n    }\r\n\r\n    private initALU(): ALU {\r\n        const i = (a: string) => a.charCodeAt(0) - 119; // i as index\r\n        const v = (m: Memory, a: string) => m[a.charCodeAt(0) - 119] ?? parseInt(a); // v as value\r\n        const commands: Record<string, Command> = {\r\n            'inp': (m, a, b) => m[i(a)] = v(m, b),\r\n            'add': (m, a, b) => m[i(a)] += v(m, b),\r\n            'mul': (m, a, b) => m[i(a)] *= v(m, b),\r\n            'div': (m, a, b) => m[i(a)] = Math.floor(m[i(a)] / v(m, b)),\r\n            'mod': (m, a, b) => m[i(a)] %= v(m, b),\r\n            'eql': (m, a, b) => m[i(a)] = m[i(a)] === v(m, b) ? 1 : 0\r\n        };\r\n\r\n        return { memory: [0, 0, 0, 0], commands };\r\n    }\r\n\r\n    private parseInput(): Instruction[] {\r\n        const matches = this.inputLines.map(x => x.split(' '));\r\n        const commands = matches.map(([kind, a, b]) =>\r\n            kind === 'inp' ? <InputInstruction>{ kind, a } : <OpInstruction>{ kind, a, b }\r\n        );\r\n        return commands;\r\n    }\r\n}\r\n","/// <reference lib=\"webworker\" />\r\n\r\nimport { lastValueFrom } from 'rxjs';\r\nimport { tap } from 'rxjs/operators';\r\nimport solutionManager from '../../core/solutionManager';\r\nimport { SolutionResult } from '../../core/solutionState';\r\nimport SolveRequest from './solveRequest';\r\n\r\nconst solutionInfos = solutionManager.getSolutionsByDay();\r\n\r\ninterface WorkerRequest {\r\n    data: SolveRequest;\r\n}\r\n\r\naddEventListener('message', async ({ data }: WorkerRequest) => {\r\n    const solutionInfo = solutionInfos.get(data.day);\r\n    if (!solutionInfo) { return; }\r\n\r\n    const solution = solutionInfo.create();\r\n    solution.init(data.input);\r\n\r\n    for (const part of [1, 2] as const) {\r\n        const observable = solution.solveWithProgress(part);\r\n        await lastValueFrom(observable.pipe(\r\n            tap(state => postMessage(state))\r\n        ));\r\n    }\r\n\r\n    // Post an invalid result to mark the end of the work.\r\n    postMessage(new SolutionResult(-1, null, 0));\r\n});\r\n","import '../solutions';\r\nimport { SolutionInfo, solutionInfoList } from './solutionInfo';\r\n\r\nclass SolutionManager {\r\n    /** Get the solutions in a (day, solutionInfo) map. */\r\n    getSolutionsByDay(): Map<number, SolutionInfo> {\r\n        return new Map(solutionInfoList.map(info => [info.day, info]));\r\n    }\r\n\r\n    /** Get the solutions in ascending order by day. */\r\n    getSolutions(): SolutionInfo[] {\r\n        return Array.from(this.getSolutionsByDay().values()).sort((a, b) => a.day - b.day);\r\n    }\r\n}\r\n\r\nconst solutionManager = new SolutionManager();\r\n\r\nexport default solutionManager;\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [240], function() { return __webpack_require__(5137); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"10857eec\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/aoc2021/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t137: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkaoc2021\"] = self[\"webpackChunkaoc2021\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(240).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["SolutionProgress","part","progress","timeMs","kind","SolutionResult","result","visualizationData","SolutionError","message","SolutionBase","minTimeBetweenUpdatesMs","_input","_inputLines","currentSolution","this","undefined","parseInputLines","input","lastValueFrom","solveWithProgress","state","Observable","subscriber","error","partFunction","part1","part2","activePart","stopwatch","Stopwatch","progressStopwatch","start","apply","stop","resultPack","next","exception","complete","current","getTime","msg","Error","emptyCount","inputLines","split","whiteSpaceLineRegex","length","line","test","splice","solutionInfoList","solutionInfo","info","day","title","ctor","push","create","values","map","x","parseInt","slice","reduce","a","i","sumsOf3","regexMatches","regex","text","record","results","exec","intersectSets","b","Set","filter","has","sub","hor","dep","parseInput","forEach","command","aim","match","commandStr","valueStr","value","binaryNumbers","halfCount","bitCounts","_","pos","bNumber","join","getRating","bNumbers","keep","position","bitCount","keepBit","playBingo","strategy","numbers","boards","lookup","marks","Array","fill","wins","targetWinCount","calledNumber","hits","get","ti","tj","tk","isBingo","add","size","boardSum","rowNumbers","row","rowSum","aNumber","col","noSolution","board","hitRow","hitCol","parseNumbersInLine","Map","lineIndex","n","lookupEntry","set","pipes","parsePipes","createMap","countOverlaps","mode","skipDiagonals","x1","y1","x2","y2","drawLine","dx","Math","sign","dy","y","simulateLanternfish","dayCount","ages","newBornAge","count","shift","crabs","minPos","maxPos","minMoves","Number","MAX_VALUE","target","moves","abs","min","delta","MIN_VALUE","max","digitSegments","digitSegmentSet","neighbors","uniqueLengths","r","digits","d","displays","display","updateProgress","decodeDisplayValue","patterns","vagueSegmentMap","generateVagueSegmentMap","segmentMap","resolveSegmentMap","decodeDigit","vagueMap","index","completedMap","Object","fromEntries","from","to","isSegmentMapValid","candidateChars","selectedChar","nextMap","c","every","p","decodeSegments","segments","indexOf","sort","digitsSegmentsByLength","resultMap","pattern","patternMap","validDigits","patternChar","vd","digitChar","entries","key","newChars","currentChars","displayMatch","patternsStr","digitsStr","chunkPairs","heightMap","getLowPoints","flood","width","height","lowPoints","np","visitedIndexes","queue","point","pointIndex","nextX","nextY","errorPoints","completePoints","Point","l","score","completeScores","floor","stack","actual","chunkStart","pop","reduceRight","grid","flashCount","step","simultaneousFlashCount","forEachCell","flash","MIN_SAFE_INTEGER","forEachNeighbor","nx","ny","action","startX","startY","maxX","maxY","mapStr","console","log","lineMatch","findPathCount","parseCaveSystem","caveSystem","repeatedCave","visited","end","pathCount","options","nextRepeatedCave","delete","caveCount","connections","caves","flat","caveIds","toUpperCase","manual","fold","points","folds","steps","draw","duplicates","pointStr","image","m","axis","template","rules","runSteps","leastCommonCount","mostCommonCount","stepCount","letters","flatMap","newLetter","pair","letterCounts","pairCombinations","pairCounts","ruleMap","rule","char","templateArray","newPairs","newPair","letterCountsAscending","other","directions","parseGrid","findShortestPathLength","enlargeGrid","endIndex","nodes","toPoint","neighborIndexes","isInBounds","toIndex","outEdges","shortestDistance","MAX_SAFE_INTEGER","iteration","invalidated","currentNodes","clear","distance","original","times","offset","flatPackets","version","rootPacket","evaluate","packet","packets","operator","binary","toString","padStart","parsePacket","literalPacket","lengthPacketHeader","countPacketHeader","parseLiteralPacket","parseOperatorPacket","groups","data","headerLength","parseInnerPacket","innerPacket","innerLength","packetLength","innerLengthTotal","packetCount","topLeft","bottomRight","searchMaxY","maxAy","hitCount","aY","aX","isHit","tl","br","canGoHigher","prev","simulation","simulateY","hit","missTop","missBottom","sum","magnitude","maxMagnitude","j","clone","sn","items","sn1","sn2","createSnailGroup","parent","sideInParent","isReduceNeeded","explodeIfNeeded","splitIfNeeded","some","child","level","explode","side","sibling","findValueSibling","createSnailValue","sv","sg","ceil","sideInverse","parseSnailNumber","prevPair","clonedGroup","z","vector","origin","rotations","createRotationMatrixes","orientedScanners","scanners","pairs","unorderedPairs","arr","overlap","p1Index","p2Index","oriented","pairIndex","findIndex","id","reorient","pointSet","s","manhattan","s1","s2","p1","rotation","rotatedPoints","multiply","offsetPoints","s1p","equal","relativeDistances","r1","r2","intersectSorted","overlapThreshold","bIndex","item","idGroup","pointsGroup","p2","rotationAngles","PI","xrs","Rx","yrs","Ry","zrs","Rz","rx","ry","rz","t","m1","m2","i1","intMatrix","cos","sin","matrix","isInfiniteLit","algorithm","enhance","boundaries","pixelCount","isInfiniteFlashing","endX","endY","algorithmIndex","indexArray","newLineRegex","algorithmMatch","imageMatch","replace","v","players","playerIndex","diceValue","rollCount","rollResult","player","countWins","pos1","score1","pos2","score2","cache","hash","cached","roll","dimensions","nextPos1","nextScore1","nextPos2","nextScore2","EMPTY","initSteps","executeSteps","reCubes","cube","intersections","reCube","hole","intersectPunched","holes","base","volume","intersect","h","z1","z2","createCube","cubes","coords","isInitStep","DOWN","UP","costs","mapInfo","targetHash","getTargetHash","findCheapest","targetIndexes","keys","k","type","targets","localeCompare","cost","hallway","hallwaySet","paths","visitedCost","crabPositionsSet","crabMoveCandidates","crab","targetCandidates","validCandidates","candidate","path","distanceToTarget","targetPos","posBefore","totalCost","groupSize","groupCount","positions","parts","crabRegex","lines","targetYPositions","padEnd","validPositions","charCodeAt","vpIndex","findPath","reverse","validCells","i2","program","findModelNumber","direction","until","sections","paramsBySection","extractParams","out","in","sectionIndex","nextTargets","nextCache","zIn","zOut","executeCompiledSection","nextTarget","find","section","w","params","commands","memory","inputIndex","instruction","solutionInfos","herds","maxMoveCount","moveCount","herd","herdIndex","nextHerds","otherHerdIndex","cucumber","cell","SolutionManager","getSolutionsByDay","solutionManager","addEventListener","solution","init","observable","pipe","tap","postMessage","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","getter","__esModule","definition","o","defineProperty","enumerable","f","e","chunkId","Promise","all","promises","u","miniCssF","obj","prop","prototype","hasOwnProperty","call","installedChunks","importScripts","chunkLoadingGlobal","self","parentChunkLoadingFunction","bind","moreModules","runtime","then"],"sourceRoot":""}